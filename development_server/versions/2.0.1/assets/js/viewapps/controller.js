webpackJsonp([32],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	
	
	
	eval('webpackJsonp([10],[\n/* 0 */,\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	var __itsa_view__ = \'controller\';if (__itsa_view__) {\n	  __itsa_view__ = null;\n	}module.exports = __webpack_require__(586);\n\n/***/ },\n/* 12 */,\n/* 13 */,\n/* 14 */,\n/* 15 */,\n/* 16 */,\n/* 17 */,\n/* 18 */,\n/* 19 */,\n/* 20 */,\n/* 21 */,\n/* 22 */,\n/* 23 */,\n/* 24 */,\n/* 25 */,\n/* 26 */,\n/* 27 */,\n/* 28 */,\n/* 29 */,\n/* 30 */,\n/* 31 */,\n/* 32 */,\n/* 33 */,\n/* 34 */,\n/* 35 */,\n/* 36 */,\n/* 37 */,\n/* 38 */,\n/* 39 */,\n/* 40 */,\n/* 41 */,\n/* 42 */,\n/* 43 */,\n/* 44 */,\n/* 45 */,\n/* 46 */,\n/* 47 */,\n/* 48 */,\n/* 49 */,\n/* 50 */,\n/* 51 */,\n/* 52 */,\n/* 53 */,\n/* 54 */,\n/* 55 */,\n/* 56 */,\n/* 57 */,\n/* 58 */,\n/* 59 */,\n/* 60 */,\n/* 61 */,\n/* 62 */,\n/* 63 */,\n/* 64 */,\n/* 65 */,\n/* 66 */,\n/* 67 */,\n/* 68 */,\n/* 69 */,\n/* 70 */,\n/* 71 */,\n/* 72 */,\n/* 73 */,\n/* 74 */,\n/* 75 */,\n/* 76 */,\n/* 77 */,\n/* 78 */,\n/* 79 */,\n/* 80 */,\n/* 81 */,\n/* 82 */,\n/* 83 */,\n/* 84 */,\n/* 85 */,\n/* 86 */,\n/* 87 */,\n/* 88 */,\n/* 89 */,\n/* 90 */,\n/* 91 */,\n/* 92 */,\n/* 93 */,\n/* 94 */,\n/* 95 */,\n/* 96 */,\n/* 97 */,\n/* 98 */,\n/* 99 */,\n/* 100 */,\n/* 101 */,\n/* 102 */,\n/* 103 */,\n/* 104 */,\n/* 105 */,\n/* 106 */,\n/* 107 */,\n/* 108 */,\n/* 109 */,\n/* 110 */,\n/* 111 */,\n/* 112 */,\n/* 113 */,\n/* 114 */,\n/* 115 */,\n/* 116 */,\n/* 117 */,\n/* 118 */,\n/* 119 */,\n/* 120 */,\n/* 121 */,\n/* 122 */,\n/* 123 */,\n/* 124 */,\n/* 125 */,\n/* 126 */,\n/* 127 */,\n/* 128 */,\n/* 129 */,\n/* 130 */,\n/* 131 */,\n/* 132 */,\n/* 133 */,\n/* 134 */,\n/* 135 */,\n/* 136 */,\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */,\n/* 142 */,\n/* 143 */,\n/* 144 */,\n/* 145 */,\n/* 146 */,\n/* 147 */,\n/* 148 */,\n/* 149 */,\n/* 150 */,\n/* 151 */,\n/* 152 */,\n/* 153 */,\n/* 154 */,\n/* 155 */,\n/* 156 */,\n/* 157 */,\n/* 158 */,\n/* 159 */,\n/* 160 */,\n/* 161 */,\n/* 162 */,\n/* 163 */,\n/* 164 */,\n/* 165 */,\n/* 166 */,\n/* 167 */,\n/* 168 */,\n/* 169 */,\n/* 170 */,\n/* 171 */,\n/* 172 */,\n/* 173 */,\n/* 174 */,\n/* 175 */,\n/* 176 */,\n/* 177 */,\n/* 178 */,\n/* 179 */,\n/* 180 */,\n/* 181 */,\n/* 182 */,\n/* 183 */,\n/* 184 */,\n/* 185 */,\n/* 186 */,\n/* 187 */,\n/* 188 */,\n/* 189 */,\n/* 190 */,\n/* 191 */,\n/* 192 */,\n/* 193 */,\n/* 194 */,\n/* 195 */,\n/* 196 */,\n/* 197 */,\n/* 198 */,\n/* 199 */,\n/* 200 */,\n/* 201 */,\n/* 202 */,\n/* 203 */,\n/* 204 */,\n/* 205 */,\n/* 206 */,\n/* 207 */,\n/* 208 */,\n/* 209 */,\n/* 210 */,\n/* 211 */,\n/* 212 */,\n/* 213 */,\n/* 214 */,\n/* 215 */,\n/* 216 */,\n/* 217 */,\n/* 218 */,\n/* 219 */,\n/* 220 */,\n/* 221 */,\n/* 222 */,\n/* 223 */,\n/* 224 */,\n/* 225 */,\n/* 226 */,\n/* 227 */,\n/* 228 */,\n/* 229 */,\n/* 230 */,\n/* 231 */,\n/* 232 */,\n/* 233 */,\n/* 234 */,\n/* 235 */,\n/* 236 */,\n/* 237 */,\n/* 238 */,\n/* 239 */,\n/* 240 */,\n/* 241 */,\n/* 242 */,\n/* 243 */,\n/* 244 */,\n/* 245 */,\n/* 246 */,\n/* 247 */,\n/* 248 */,\n/* 249 */,\n/* 250 */,\n/* 251 */,\n/* 252 */,\n/* 253 */,\n/* 254 */,\n/* 255 */,\n/* 256 */,\n/* 257 */,\n/* 258 */,\n/* 259 */,\n/* 260 */,\n/* 261 */,\n/* 262 */,\n/* 263 */,\n/* 264 */,\n/* 265 */,\n/* 266 */,\n/* 267 */,\n/* 268 */,\n/* 269 */,\n/* 270 */,\n/* 271 */,\n/* 272 */,\n/* 273 */,\n/* 274 */,\n/* 275 */,\n/* 276 */,\n/* 277 */,\n/* 278 */,\n/* 279 */,\n/* 280 */,\n/* 281 */,\n/* 282 */,\n/* 283 */,\n/* 284 */,\n/* 285 */,\n/* 286 */,\n/* 287 */,\n/* 288 */,\n/* 289 */,\n/* 290 */,\n/* 291 */,\n/* 292 */,\n/* 293 */,\n/* 294 */,\n/* 295 */,\n/* 296 */,\n/* 297 */,\n/* 298 */,\n/* 299 */,\n/* 300 */,\n/* 301 */,\n/* 302 */,\n/* 303 */,\n/* 304 */,\n/* 305 */,\n/* 306 */,\n/* 307 */,\n/* 308 */,\n/* 309 */,\n/* 310 */,\n/* 311 */,\n/* 312 */,\n/* 313 */,\n/* 314 */,\n/* 315 */,\n/* 316 */,\n/* 317 */,\n/* 318 */,\n/* 319 */,\n/* 320 */,\n/* 321 */,\n/* 322 */,\n/* 323 */,\n/* 324 */,\n/* 325 */,\n/* 326 */,\n/* 327 */,\n/* 328 */,\n/* 329 */,\n/* 330 */,\n/* 331 */,\n/* 332 */,\n/* 333 */,\n/* 334 */,\n/* 335 */,\n/* 336 */,\n/* 337 */,\n/* 338 */,\n/* 339 */,\n/* 340 */,\n/* 341 */,\n/* 342 */,\n/* 343 */,\n/* 344 */,\n/* 345 */,\n/* 346 */,\n/* 347 */,\n/* 348 */,\n/* 349 */,\n/* 350 */,\n/* 351 */,\n/* 352 */,\n/* 353 */,\n/* 354 */,\n/* 355 */,\n/* 356 */,\n/* 357 */,\n/* 358 */,\n/* 359 */,\n/* 360 */,\n/* 361 */,\n/* 362 */,\n/* 363 */,\n/* 364 */,\n/* 365 */,\n/* 366 */,\n/* 367 */,\n/* 368 */,\n/* 369 */,\n/* 370 */,\n/* 371 */,\n/* 372 */,\n/* 373 */,\n/* 374 */,\n/* 375 */,\n/* 376 */,\n/* 377 */,\n/* 378 */,\n/* 379 */,\n/* 380 */,\n/* 381 */,\n/* 382 */,\n/* 383 */,\n/* 384 */,\n/* 385 */,\n/* 386 */,\n/* 387 */\n2,\n/* 388 */\n3,\n/* 389 */\n[319, 431, 399, 388, 390],\n/* 390 */\n[385, 401],\n/* 391 */\n7,\n/* 392 */\n[279, 415],\n/* 393 */\n[296, 453, 399, 389, 518, 408, 434, 435, 419, 436, 388, 387, 415, 402, 390],\n/* 394 */\n[329, 403, 406, 399, 389, 413, 433, 407, 408, 457, 400, 409, 436, 395, 422, 463, 550, 442, 387, 444, 445, 390],\n/* 395 */\n[343, 425, 397, 399, 400, 409, 421, 388, 387, 390],\n/* 396 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	exports.capitalize = capitalize;\n	exports.callbackName = callbackName;\n	exports.isObject = isObject;\n	exports.extend = extend;\n	exports.isFunction = isFunction;\n	exports.object = object;\n	exports.isArguments = isArguments;\n	exports.throwIf = throwIf;\n\n	function capitalize(string) {\n	    return string.charAt(0).toUpperCase() + string.slice(1);\n	}\n\n	function callbackName(string, prefix) {\n	    prefix = prefix || \"on\";\n	    return prefix + exports.capitalize(string);\n	}\n\n	/*\n	 * isObject, extend, isFunction, isArguments are taken from undescore/lodash in\n	 * order to remove the dependency\n	 */\n\n	function isObject(obj) {\n	    var type = typeof obj;\n	    return type === \"function\" || type === \"object\" && !!obj;\n	}\n\n	function extend(obj) {\n	    if (!isObject(obj)) {\n	        return obj;\n	    }\n	    var source, prop;\n	    for (var i = 1, length = arguments.length; i < length; i++) {\n	        source = arguments[i];\n	        for (prop in source) {\n	            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n	                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n	                Object.defineProperty(obj, prop, propertyDescriptor);\n	            } else {\n	                obj[prop] = source[prop];\n	            }\n	        }\n	    }\n	    return obj;\n	}\n\n	function isFunction(value) {\n	    return typeof value === \"function\";\n	}\n\n	exports.EventEmitter = __webpack_require__(570);\n\n	exports.nextTick = function (callback) {\n	    setTimeout(callback, 0);\n	};\n\n	function object(keys, vals) {\n	    var o = {},\n	        i = 0;\n	    for (; i < keys.length; i++) {\n	        o[keys[i]] = vals[i];\n	    }\n	    return o;\n	}\n\n	function isArguments(value) {\n	    return typeof value === \"object\" && \"callee\" in value && typeof value.length === \"number\";\n	}\n\n	function throwIf(val, msg) {\n	    if (val) {\n	        throw Error(msg || val);\n	    }\n	}\n\n/***/ },\n/* 397 */\n[290, 387],\n/* 398 */\n[292, 464],\n/* 399 */\n30,\n/* 400 */\n31,\n/* 401 */\n32,\n/* 402 */\n33,\n/* 403 */\n[274, 387],\n/* 404 */\n[350, 397, 388, 401, 441],\n/* 405 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	var _ = __webpack_require__(396),\n	    maker = __webpack_require__(478).instanceJoinCreator;\n\n	/**\n	 * Extract child listenables from a parent from their\n	 * children property and return them in a keyed Object\n	 *\n	 * @param {Object} listenable The parent listenable\n	 */\n	var mapChildListenables = function mapChildListenables(listenable) {\n	    var i = 0,\n	        children = {},\n	        childName;\n	    for (; i < (listenable.children || []).length; ++i) {\n	        childName = listenable.children[i];\n	        if (listenable[childName]) {\n	            children[childName] = listenable[childName];\n	        }\n	    }\n	    return children;\n	};\n\n	/**\n	 * Make a flat dictionary of all listenables including their\n	 * possible children (recursively), concatenating names in camelCase.\n	 *\n	 * @param {Object} listenables The top-level listenables\n	 */\n	var flattenListenables = function flattenListenables(listenables) {\n	    var flattened = {};\n	    for (var key in listenables) {\n	        var listenable = listenables[key];\n	        var childMap = mapChildListenables(listenable);\n\n	        // recursively flatten children\n	        var children = flattenListenables(childMap);\n\n	        // add the primary listenable and chilren\n	        flattened[key] = listenable;\n	        for (var childKey in children) {\n	            var childListenable = children[childKey];\n	            flattened[key + _.capitalize(childKey)] = childListenable;\n	        }\n	    }\n\n	    return flattened;\n	};\n\n	/**\n	 * A module of methods related to listening.\n	 */\n	module.exports = {\n\n	    /**\n	     * An internal utility function used by `validateListening`\n	     *\n	     * @param {Action|Store} listenable The listenable we want to search for\n	     * @returns {Boolean} The result of a recursive search among `this.subscriptions`\n	     */\n	    hasListener: function hasListener(listenable) {\n	        var i = 0,\n	            j,\n	            listener,\n	            listenables;\n	        for (; i < (this.subscriptions || []).length; ++i) {\n	            listenables = [].concat(this.subscriptions[i].listenable);\n	            for (j = 0; j < listenables.length; j++) {\n	                listener = listenables[j];\n	                if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {\n	                    return true;\n	                }\n	            }\n	        }\n	        return false;\n	    },\n\n	    /**\n	     * A convenience method that listens to all listenables in the given object.\n	     *\n	     * @param {Object} listenables An object of listenables. Keys will be used as callback method names.\n	     */\n	    listenToMany: function listenToMany(listenables) {\n	        var allListenables = flattenListenables(listenables);\n	        for (var key in allListenables) {\n	            var cbname = _.callbackName(key),\n	                localname = this[cbname] ? cbname : this[key] ? key : undefined;\n	            if (localname) {\n	                this.listenTo(allListenables[key], localname, this[cbname + \"Default\"] || this[localname + \"Default\"] || localname);\n	            }\n	        }\n	    },\n\n	    /**\n	     * Checks if the current context can listen to the supplied listenable\n	     *\n	     * @param {Action|Store} listenable An Action or Store that should be\n	     *  listened to.\n	     * @returns {String|Undefined} An error message, or undefined if there was no problem.\n	     */\n	    validateListening: function validateListening(listenable) {\n	        if (listenable === this) {\n	            return \"Listener is not able to listen to itself\";\n	        }\n	        if (!_.isFunction(listenable.listen)) {\n	            return listenable + \" is missing a listen method\";\n	        }\n	        if (listenable.hasListener && listenable.hasListener(this)) {\n	            return \"Listener cannot listen to this listenable because of circular loop\";\n	        }\n	    },\n\n	    /**\n	     * Sets up a subscription to the given listenable for the context object\n	     *\n	     * @param {Action|Store} listenable An Action or Store that should be\n	     *  listened to.\n	     * @param {Function|String} callback The callback to register as event handler\n	     * @param {Function|String} defaultCallback The callback to register as default handler\n	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\n	     */\n	    listenTo: function listenTo(listenable, callback, defaultCallback) {\n	        var desub,\n	            unsubscriber,\n	            subscriptionobj,\n	            subs = this.subscriptions = this.subscriptions || [];\n	        _.throwIf(this.validateListening(listenable));\n	        this.fetchInitialState(listenable, defaultCallback);\n	        desub = listenable.listen(this[callback] || callback, this);\n	        unsubscriber = function () {\n	            var index = subs.indexOf(subscriptionobj);\n	            _.throwIf(index === -1, \"Tried to remove listen already gone from subscriptions list!\");\n	            subs.splice(index, 1);\n	            desub();\n	        };\n	        subscriptionobj = {\n	            stop: unsubscriber,\n	            listenable: listenable\n	        };\n	        subs.push(subscriptionobj);\n	        return subscriptionobj;\n	    },\n\n	    /**\n	     * Stops listening to a single listenable\n	     *\n	     * @param {Action|Store} listenable The action or store we no longer want to listen to\n	     * @returns {Boolean} True if a subscription was found and removed, otherwise false.\n	     */\n	    stopListeningTo: function stopListeningTo(listenable) {\n	        var sub,\n	            i = 0,\n	            subs = this.subscriptions || [];\n	        for (; i < subs.length; i++) {\n	            sub = subs[i];\n	            if (sub.listenable === listenable) {\n	                sub.stop();\n	                _.throwIf(subs.indexOf(sub) !== -1, \"Failed to remove listen from subscriptions list!\");\n	                return true;\n	            }\n	        }\n	        return false;\n	    },\n\n	    /**\n	     * Stops all subscriptions and empties subscriptions array\n	     */\n	    stopListeningToAll: function stopListeningToAll() {\n	        var remaining,\n	            subs = this.subscriptions || [];\n	        while (remaining = subs.length) {\n	            subs[0].stop();\n	            _.throwIf(subs.length !== remaining - 1, \"Failed to remove listen from subscriptions list!\");\n	        }\n	    },\n\n	    /**\n	     * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.\n	     * @param {Action|Store} listenable The publisher we want to get initial state from\n	     * @param {Function|String} defaultCallback The method to receive the data\n	     */\n	    fetchInitialState: function fetchInitialState(listenable, defaultCallback) {\n	        defaultCallback = defaultCallback && this[defaultCallback] || defaultCallback;\n	        var me = this;\n	        if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {\n	            var data = listenable.getInitialState();\n	            if (data && _.isFunction(data.then)) {\n	                data.then(function () {\n	                    defaultCallback.apply(me, arguments);\n	                });\n	            } else {\n	                defaultCallback.call(this, data);\n	            }\n	        }\n	    },\n\n	    /**\n	     * The callback will be called once all listenables have triggered at least once.\n	     * It will be invoked with the last emission from each listenable.\n	     * @param {...Publishers} publishers Publishers that should be tracked.\n	     * @param {Function|String} callback The method to call when all publishers have emitted\n	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n	     */\n	    joinTrailing: maker(\"last\"),\n\n	    /**\n	     * The callback will be called once all listenables have triggered at least once.\n	     * It will be invoked with the first emission from each listenable.\n	     * @param {...Publishers} publishers Publishers that should be tracked.\n	     * @param {Function|String} callback The method to call when all publishers have emitted\n	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n	     */\n	    joinLeading: maker(\"first\"),\n\n	    /**\n	     * The callback will be called once all listenables have triggered at least once.\n	     * It will be invoked with all emission from each listenable.\n	     * @param {...Publishers} publishers Publishers that should be tracked.\n	     * @param {Function|String} callback The method to call when all publishers have emitted\n	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n	     */\n	    joinConcat: maker(\"all\"),\n\n	    /**\n	     * The callback will be called once all listenables have triggered.\n	     * If a callback triggers twice before that happens, an error is thrown.\n	     * @param {...Publishers} publishers Publishers that should be tracked.\n	     * @param {Function|String} callback The method to call when all publishers have emitted\n	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n	     */\n	    joinStrict: maker(\"strict\")\n	};\n\n/***/ },\n/* 406 */\n[293, 392, 411, 452, 519, 462, 388, 443],\n/* 407 */\n[327, 461, 387],\n/* 408 */\n43,\n/* 409 */\n[338, 525, 413],\n/* 410 */\n[275, 403, 560, 390],\n/* 411 */\n[281, 452, 426, 437, 438, 387],\n/* 412 */\n[284, 392, 411, 437, 438],\n/* 413 */\n[320, 389, 417, 435, 419, 399, 418, 467, 387, 390],\n/* 414 */\n[356, 404, 441],\n/* 415 */\n[375, 387],\n/* 416 */\n[268, 465],\n/* 417 */\n[324, 389, 390],\n/* 418 */\n[332, 388, 387],\n/* 419 */\n60,\n/* 420 */\n[354, 414, 462, 440],\n/* 421 */\n[358, 387],\n/* 422 */\n63,\n/* 423 */\n64,\n/* 424 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	var Reflux = __webpack_require__(573);\n\n	Reflux.connect = __webpack_require__(575);\n\n	Reflux.connectFilter = __webpack_require__(576);\n\n	Reflux.ListenerMixin = __webpack_require__(448);\n\n	Reflux.listenTo = __webpack_require__(577);\n\n	Reflux.listenToMany = __webpack_require__(578);\n\n	module.exports = Reflux;\n\n/***/ },\n/* 425 */\n[271, 397, 388, 387],\n/* 426 */\n[283, 392, 387],\n/* 427 */\n[287, 459, 387],\n/* 428 */\n[288, 406, 437, 438, 387],\n/* 429 */\n[298, 454, 394],\n/* 430 */\n[299, 387],\n/* 431 */\n[301, 388, 422, 390],\n/* 432 */\n[304, 451, 403, 410, 406, 429, 394, 522, 400, 388, 423, 387, 443, 402, 390],\n/* 433 */\n[321, 389, 408, 387],\n/* 434 */\n79,\n/* 435 */\n[334, 415],\n/* 436 */\n[342, 434, 399, 389, 408, 395, 388, 387, 390],\n/* 437 */\n[359, 387],\n/* 438 */\n83,\n/* 439 */\n84,\n/* 440 */\n85,\n/* 441 */\n86,\n/* 442 */\n[372, 503, 433, 418, 388, 387, 390],\n/* 443 */\n[373, 391],\n/* 444 */\n[380, 391],\n/* 445 */\n[382, 390],\n/* 446 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n\n	exports.createdStores = [];\n\n	exports.createdActions = [];\n\n	exports.reset = function () {\n	    while (exports.createdStores.length) {\n	        exports.createdStores.pop();\n	    }\n	    while (exports.createdActions.length) {\n	        exports.createdActions.pop();\n	    }\n	};\n\n/***/ },\n/* 447 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	var _ = __webpack_require__(396);\n\n	/**\n	 * A module of methods for object that you want to be able to listen to.\n	 * This module is consumed by `createStore` and `createAction`\n	 */\n	module.exports = {\n\n	    /**\n	     * Hook used by the publisher that is invoked before emitting\n	     * and before `shouldEmit`. The arguments are the ones that the action\n	     * is invoked with. If this function returns something other than\n	     * undefined, that will be passed on as arguments for shouldEmit and\n	     * emission.\n	     */\n	    preEmit: function preEmit() {},\n\n	    /**\n	     * Hook used by the publisher after `preEmit` to determine if the\n	     * event should be emitted with given arguments. This may be overridden\n	     * in your application, default implementation always returns true.\n	     *\n	     * @returns {Boolean} true if event should be emitted\n	     */\n	    shouldEmit: function shouldEmit() {\n	        return true;\n	    },\n\n	    /**\n	     * Subscribes the given callback for action triggered\n	     *\n	     * @param {Function} callback The callback to register as event handler\n	     * @param {Mixed} [optional] bindContext The context to bind the callback with\n	     * @returns {Function} Callback that unsubscribes the registered event handler\n	     */\n	    listen: function listen(callback, bindContext) {\n	        bindContext = bindContext || this;\n	        var eventHandler = function eventHandler(args) {\n	            if (aborted) {\n	                return;\n	            }\n	            callback.apply(bindContext, args);\n	        },\n	            me = this,\n	            aborted = false;\n	        this.emitter.addListener(this.eventLabel, eventHandler);\n	        return function () {\n	            aborted = true;\n	            me.emitter.removeListener(me.eventLabel, eventHandler);\n	        };\n	    },\n\n	    /**\n	     * Publishes an event using `this.emitter` (if `shouldEmit` agrees)\n	     */\n	    trigger: function trigger() {\n	        var args = arguments,\n	            pre = this.preEmit.apply(this, args);\n	        args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);\n	        if (this.shouldEmit.apply(this, args)) {\n	            this.emitter.emit(this.eventLabel, args);\n	        }\n	    },\n\n	    /**\n	     * Tries to publish the event on the next tick\n	     */\n	    triggerAsync: function triggerAsync() {\n	        var args = arguments,\n	            me = this;\n	        _.nextTick(function () {\n	            me.trigger.apply(me, args);\n	        });\n	    },\n\n	    /**\n	     * Wraps the trigger mechanism with a deferral function.\n	     *\n	     * @param {Function} callback the deferral function,\n	     *        first argument is the resolving function and the\n	     *        rest are the arguments provided from the previous\n	     *        trigger invocation\n	     */\n	    deferWith: function deferWith(callback) {\n	        var oldTrigger = this.trigger,\n	            ctx = this,\n	            resolver = function resolver() {\n	            oldTrigger.apply(ctx, arguments);\n	        };\n	        this.trigger = function () {\n	            callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));\n	        };\n	    }\n\n	};\n\n/***/ },\n/* 448 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	var _ = __webpack_require__(396),\n	    ListenerMethods = __webpack_require__(405);\n\n	/**\n	 * A module meant to be consumed as a mixin by a React component. Supplies the methods from\n	 * `ListenerMethods` mixin and takes care of teardown of subscriptions.\n	 * Note that if you\'re using the `connect` mixin you don\'t need this mixin, as connect will\n	 * import everything this mixin contains!\n	 */\n	module.exports = _.extend({\n\n	  /**\n	   * Cleans up all listener previously registered.\n	   */\n	  componentWillUnmount: ListenerMethods.stopListeningToAll\n\n	}, ListenerMethods);\n\n/***/ },\n/* 449 */\n/***/ function(module, exports) {\n\n	\n\n/***/ },\n/* 450 */\n109,\n/* 451 */\n[270, 450, 391, 542, 546, 553, 556, 390],\n/* 452 */\n[282, 387],\n/* 453 */\n[297, 436, 387, 390],\n/* 454 */\n[306, 451, 492, 410, 394, 400, 387, 444],\n/* 455 */\n[313, 410, 429, 432, 388, 423],\n/* 456 */\n[326, 512, 463, 465, 466],\n/* 457 */\n[328, 540],\n/* 458 */\n[331, 415],\n/* 459 */\n[335, 389, 417, 419, 401],\n/* 460 */\n[336, 397, 406, 388],\n/* 461 */\n120,\n/* 462 */\n121,\n/* 463 */\n[361, 554],\n/* 464 */\n[366, 399, 408, 394, 387, 470, 390],\n/* 465 */\n124,\n/* 466 */\n125,\n/* 467 */\n126,\n/* 468 */\n[369, 391, 387],\n/* 469 */\n[370, 391],\n/* 470 */\n129,\n/* 471 */\n130,\n/* 472 */\n[384, 389, 417, 407, 467, 387, 390],\n/* 473 */\n[264, 474],\n/* 474 */\n[265, 568, 567],\n/* 475 */\n/***/ function(module, exports) {\n\n	/**\n	 * A module of methods that you want to include in all actions.\n	 * This module is consumed by `createAction`.\n	 */\n	\"use strict\";\n\n	module.exports = {};\n\n/***/ },\n/* 476 */\n/***/ function(module, exports) {\n\n	/**\n	 * A module of methods that you want to include in all stores.\n	 * This module is consumed by `createStore`.\n	 */\n	\"use strict\";\n\n	module.exports = {};\n\n/***/ },\n/* 477 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	var _ = __webpack_require__(396),\n	    Keep = __webpack_require__(446),\n	    mixer = __webpack_require__(574),\n	    bindMethods = __webpack_require__(571);\n\n	var allowed = { preEmit: 1, shouldEmit: 1 };\n\n	/**\n	 * Creates an event emitting Data Store. It is mixed in with functions\n	 * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`\n	 * and `shouldEmit` may be overridden in the definition object.\n	 *\n	 * @param {Object} definition The data store object definition\n	 * @returns {Store} A data store instance\n	 */\n	module.exports = function (definition) {\n\n	    var StoreMethods = __webpack_require__(476),\n	        PublisherMethods = __webpack_require__(447),\n	        ListenerMethods = __webpack_require__(405);\n\n	    definition = definition || {};\n\n	    for (var a in StoreMethods) {\n	        if (!allowed[a] && (PublisherMethods[a] || ListenerMethods[a])) {\n	            throw new Error(\"Cannot override API method \" + a + \" in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\");\n	        }\n	    }\n\n	    for (var d in definition) {\n	        if (!allowed[d] && (PublisherMethods[d] || ListenerMethods[d])) {\n	            throw new Error(\"Cannot override API method \" + d + \" in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.\");\n	        }\n	    }\n\n	    definition = mixer(definition);\n\n	    function Store() {\n	        var i = 0,\n	            arr;\n	        this.subscriptions = [];\n	        this.emitter = new _.EventEmitter();\n	        this.eventLabel = \"change\";\n	        bindMethods(this, definition);\n	        if (this.init && _.isFunction(this.init)) {\n	            this.init();\n	        }\n	        if (this.listenables) {\n	            arr = [].concat(this.listenables);\n	            for (; i < arr.length; i++) {\n	                this.listenToMany(arr[i]);\n	            }\n	        }\n	    }\n\n	    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);\n\n	    var store = new Store();\n	    Keep.createdStores.push(store);\n\n	    return store;\n	};\n\n/***/ },\n/* 478 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/**\n	 * Internal module used to create static and instance join methods\n	 */\n\n	\"use strict\";\n\n	var createStore = __webpack_require__(477),\n	    _ = __webpack_require__(396);\n\n	var slice = Array.prototype.slice,\n	    strategyMethodNames = {\n	    strict: \"joinStrict\",\n	    first: \"joinLeading\",\n	    last: \"joinTrailing\",\n	    all: \"joinConcat\"\n	};\n\n	/**\n	 * Used in `index.js` to create the static join methods\n	 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\n	 * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy\n	 */\n	exports.staticJoinCreator = function (strategy) {\n	    return function () /* listenables... */{\n	        var listenables = slice.call(arguments);\n	        return createStore({\n	            init: function init() {\n	                this[strategyMethodNames[strategy]].apply(this, listenables.concat(\"triggerAsync\"));\n	            }\n	        });\n	    };\n	};\n\n	/**\n	 * Used in `ListenerMethods.js` to create the instance join methods\n	 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments\n	 * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy\n	 */\n	exports.instanceJoinCreator = function (strategy) {\n	    return function () /* listenables..., callback*/{\n	        _.throwIf(arguments.length < 2, \"Cannot create a join with less than 2 listenables!\");\n	        var listenables = slice.call(arguments),\n	            callback = listenables.pop(),\n	            numberOfListenables = listenables.length,\n	            join = {\n	            numberOfListenables: numberOfListenables,\n	            callback: this[callback] || callback,\n	            listener: this,\n	            strategy: strategy\n	        },\n	            i,\n	            cancels = [],\n	            subobj;\n	        for (i = 0; i < numberOfListenables; i++) {\n	            _.throwIf(this.validateListening(listenables[i]));\n	        }\n	        for (i = 0; i < numberOfListenables; i++) {\n	            cancels.push(listenables[i].listen(newListener(i, join), this));\n	        }\n	        reset(join);\n	        subobj = { listenable: listenables };\n	        subobj.stop = makeStopper(subobj, cancels, this);\n	        this.subscriptions = (this.subscriptions || []).concat(subobj);\n	        return subobj;\n	    };\n	};\n\n	// ---- internal join functions ----\n\n	function makeStopper(subobj, cancels, context) {\n	    return function () {\n	        var i,\n	            subs = context.subscriptions,\n	            index = subs ? subs.indexOf(subobj) : -1;\n	        _.throwIf(index === -1, \"Tried to remove join already gone from subscriptions list!\");\n	        for (i = 0; i < cancels.length; i++) {\n	            cancels[i]();\n	        }\n	        subs.splice(index, 1);\n	    };\n	}\n\n	function reset(join) {\n	    join.listenablesEmitted = new Array(join.numberOfListenables);\n	    join.args = new Array(join.numberOfListenables);\n	}\n\n	function newListener(i, join) {\n	    return function () {\n	        var callargs = slice.call(arguments);\n	        if (join.listenablesEmitted[i]) {\n	            switch (join.strategy) {\n	                case \"strict\":\n	                    throw new Error(\"Strict join failed because listener triggered twice.\");\n	                case \"last\":\n	                    join.args[i] = callargs;break;\n	                case \"all\":\n	                    join.args[i].push(callargs);\n	            }\n	        } else {\n	            join.listenablesEmitted[i] = true;\n	            join.args[i] = join.strategy === \"all\" ? [callargs] : callargs;\n	        }\n	        emitIfAllListenablesEmitted(join);\n	    };\n	}\n\n	function emitIfAllListenablesEmitted(join) {\n	    for (var i = 0; i < join.numberOfListenables; i++) {\n	        if (!join.listenablesEmitted[i]) {\n	            return;\n	        }\n	    }\n	    join.callback.apply(join.listener, join.args);\n	    reset(join);\n	}\n\n/***/ },\n/* 479 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	var Reflux = __webpack_require__(424),\n	    constants = __webpack_require__(582),\n	    actions;\n\n	actions = [constants.TOGGLE_MENU];\n\n	module.exports = Reflux.createActions(actions);\n\n/***/ },\n/* 480 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	var menuActivated;\n\n	var Reflux = __webpack_require__(424),\n	    actions = __webpack_require__(479),\n	    ItsaRefluxClientStorage = __webpack_require__(485);\n\n	var store = Reflux.createStore({\n	    mixins: [ItsaRefluxClientStorage],\n\n	    listenables: [actions],\n\n	    onToggleMenu: function onToggleMenu() {\n	        menuActivated = !menuActivated;\n	        this.trigger({ menuActivated: menuActivated });\n	    },\n\n	    getInitialState: function getInitialState() {\n	        var initialSate = {\n	            menuActivated: false\n	        },\n	            state = this.readStateFromClientStorage(initialSate);\n	        menuActivated = state.menuActivated;\n	        return state;\n	    }\n	});\n\n	module.exports = store;\n\n/***/ },\n/* 481 */\n449,\n/* 482 */\n449,\n/* 483 */\n449,\n/* 484 */\n449,\n/* 485 */\n/***/ function(module, exports, __webpack_require__) {\n\n	/* WEBPACK VAR INJECTION */(function(global) {\'use strict\';\n\n	var isNode = typeof global !== \'undefined\' && ({}).toString.call(global) === \'[object global]\' && (!global.document || ({}).toString.call(global.document) !== \'[object HTMLDocument]\');\n	var alreadySet = false;\n\n	var WINDOW = isNode ? {} : window,\n	    objectAssign = __webpack_require__(569),\n	    localStorage = __webpack_require__(486),\n	    KEY_ID = \'itsaRefluxClientStorage\',\n	    MIN_SESSION_BROWSERS_NO_HISTORY = 3600; // sec\n\n	var setupListener = function setupListener() {\n	    // do not use arrow function!\n	    if (alreadySet) {\n	        return;\n	    }\n	    // make sure only one listeners kieeps running:\n	    alreadySet = true;\n	    var eventHandler = function eventHandler(triggerState) {\n	        // triggerState is an array where every item is an argument of the triggerFn\n	        var newState = {};\n	        objectAssign(newState, triggerState[0]);\n	        localStorage.setItem(KEY_ID, { time: Date.now(), state: newState });\n	    };\n	    this.emitter.addListener(\'change\', eventHandler);\n	};\n\n	var isBrowserWithHistory = function isBrowserWithHistory() {\n	    // only activated to browsers with history-support\n	    return WINDOW.history && WINDOW.history.pushState;\n	};\n\n	var RefluxClientStorageMixin = {\n	    envBrowser: function envBrowser() {\n	        return !isNode;\n	    },\n\n	    readStateFromClientStorage: function readStateFromClientStorage(initialState) {\n	        var localState;\n	        if (this.envBrowser() && localStorage) {\n	            var controller = __webpack_require__(487);\n	            var sessionTime = controller.getProps().__sessiontime;\n\n	            if (!isBrowserWithHistory()) {\n	                // force a specific sessiontime, to prevent stateloses during navigation\n	                sessionTime = Math.max(sessionTime, MIN_SESSION_BROWSERS_NO_HISTORY);\n	            }\n	            localState = localStorage.getItem(KEY_ID, true);\n\n	            if (localState && localState.time && localState.time > Date.now() - 1000 * sessionTime) {\n	                objectAssign(initialState, localState.state);\n	            }\n	            setupListener.call(this);\n	        }\n	        return initialState;\n	    }\n\n	};\n\n	module.exports = RefluxClientStorageMixin;\n	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 486 */\n/***/ function(module, exports) {\n\n	\'use strict\';\n\n	var DATEPATTERN = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z/,\n	    // datepattern will return date-type\n	REVIVER = function REVIVER(key, value) {\n	    return DATEPATTERN.test(value) ? new Date(value) : value;\n	};\n\n	var Storage = {\n	    /**\n	     *\n	     *\n	     * @method getItem\n	     * @param key {String}\n	     * @param parseDate {boolean}\n	     * @since 0.0.1\n	     */\n	    getItem: function getItem(key, parseDate) {\n	        var value = localStorage.getItem(key),\n	            obj;\n	        if (value) {\n	            try {\n	                obj = JSON.parse(value, parseDate ? REVIVER : null);\n	            } catch (err) {\n	                // error in item: remove it from store\n	                obj = {};\n	            }\n	        }\n	        return obj;\n	    },\n\n	    /**\n	     *\n	     *\n	     * @method setItem\n	     * @param key {String}\n	     * @param value {Any}\n	     * @since 0.0.1\n	     */\n	    setItem: function setItem(key, value) {\n	        try {\n	            value = JSON.stringify(value);\n	            localStorage.setItem(key, value);\n	        } catch (err) {\n	            // error storing\n	            return false;\n	        }\n	        return true;\n	    },\n\n	    /**\n	     *\n	     *\n	     * @method removeItem\n	     * @param key {String}\n	     * @since 0.0.1\n	     */\n	    removeItem: function removeItem(key) {\n	        try {\n	            localStorage.removeItem(key);\n	        } catch (err) {\n	            // error removing\n	            return false;\n	        }\n	        return true;\n	    }\n	};\n\n	module.exports = Storage;\n\n/***/ },\n/* 487 */\n[261, 564, 565, 488],\n/* 488 */\n148,\n/* 489 */\n[269, 392, 412, 391, 497, 533, 536, 402],\n/* 490 */\n[272, 392, 411, 412, 391, 395, 404, 443, 471, 402],\n/* 491 */\n188,\n/* 492 */\n[273, 493, 458, 561, 387],\n/* 493 */\n[276, 391, 545, 401, 468, 387],\n/* 494 */\n[277, 402],\n/* 495 */\n[278, 392, 412, 420, 394, 402],\n/* 496 */\n[280, 401],\n/* 497 */\n[285, 397, 388, 469],\n/* 498 */\n[286, 403, 391],\n/* 499 */\n[289, 392, 401],\n/* 500 */\n[291, 426, 502, 453, 393, 431, 399, 389, 413, 504, 455, 515, 407, 394, 400, 459, 409, 526, 388, 464, 557, 391],\n/* 501 */\n[294, 409, 547, 442, 445],\n/* 502 */\n[295, 397, 417, 472, 390],\n/* 503 */\n[300, 430, 431, 399, 389, 413, 408, 434, 418, 400, 435, 419, 409, 395, 388, 422, 387, 445, 390],\n/* 504 */\n[302, 389, 413, 555],\n/* 505 */\n[303, 416, 398, 393, 389, 415],\n/* 506 */\n[305, 392, 428, 398, 393, 389],\n/* 507 */\n[307, 392, 428, 398, 393, 389],\n/* 508 */\n[308, 392, 428, 398, 393, 389],\n/* 509 */\n[309, 416, 410, 427, 398, 393, 389, 394, 395, 388, 387],\n/* 510 */\n[310, 398, 393, 389, 390],\n/* 511 */\n[311, 416, 427, 398, 393, 389, 395, 388],\n/* 512 */\n[312, 391, 549, 469],\n/* 513 */\n[314, 416, 410, 427, 398, 393, 389, 395, 388, 387, 390],\n/* 514 */\n[315, 395, 421, 388, 401],\n/* 515 */\n[316, 489, 490, 491, 494, 495, 391, 498, 499, 398, 393, 429, 514, 432, 505, 506, 508, 454, 507, 509, 510, 511, 513, 455, 389, 520, 521, 407, 394, 524, 529, 530, 531, 528, 544, 516],\n/* 516 */\n[317, 403, 517, 394, 400, 559],\n/* 517 */\n[318, 388],\n/* 518 */\n215,\n/* 519 */\n[322, 411],\n/* 520 */\n[323, 496, 391, 397, 407, 394, 395, 388, 441, 551],\n/* 521 */\n[325, 403, 411, 430, 393, 433, 406, 418, 432, 400, 461, 395],\n/* 522 */\n[330, 430, 458, 409, 501],\n/* 523 */\n[333, 387],\n/* 524 */\n[337, 425, 397, 406, 456, 460, 421, 388],\n/* 525 */\n[339, 523],\n/* 526 */\n[340, 389, 407, 457, 527, 422, 442, 387],\n/* 527 */\n[341, 397, 425, 460, 421, 388, 401],\n/* 528 */\n[344, 403],\n/* 529 */\n[345, 392, 412, 456, 404, 466, 471, 402, 562],\n/* 530 */\n227,\n/* 531 */\n[346, 392, 426, 412, 532, 404, 535, 537, 420, 534, 538, 414, 539, 439, 387, 402, 390],\n/* 532 */\n[347, 404],\n/* 533 */\n[348, 404],\n/* 534 */\n[349, 420],\n/* 535 */\n[351, 414],\n/* 536 */\n[352, 404],\n/* 537 */\n[353, 414, 439, 548, 440],\n/* 538 */\n[355, 414, 440],\n/* 539 */\n[357, 420],\n/* 540 */\n237,\n/* 541 */\n238,\n/* 542 */\n[360, 541],\n/* 543 */\n[362, 563],\n/* 544 */\n[363, 393, 389, 387],\n/* 545 */\n[364, 391, 543, 468, 387],\n/* 546 */\n[365, 450],\n/* 547 */\n[367, 472, 390],\n/* 548 */\n[368, 439],\n/* 549 */\n246,\n/* 550 */\n247,\n/* 551 */\n248,\n/* 552 */\n249,\n/* 553 */\n[371, 552],\n/* 554 */\n[374, 470],\n/* 555 */\n252,\n/* 556 */\n253,\n/* 557 */\n[376, 389, 387],\n/* 558 */\n[377, 391],\n/* 559 */\n[378, 558],\n/* 560 */\n[379, 423],\n/* 561 */\n[381, 391, 423, 444],\n/* 562 */\n259,\n/* 563 */\n[383, 387],\n/* 564 */\n[386, 500],\n/* 565 */\n[262, 566, 473, 473],\n/* 566 */\n[263, 474],\n/* 567 */\n153,\n/* 568 */\n154,\n/* 569 */\n185,\n/* 570 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	//\n	// We store our EE objects in a plain object whose properties are event names.\n	// If `Object.create(null)` is not supported we prefix the event names with a\n	// `~` to make sure that the built-in object properties are not overridden or\n	// used as an attack vector.\n	// We also assume that `Object.create(null)` is available when the event name\n	// is an ES6 Symbol.\n	//\n	var prefix = typeof Object.create !== \'function\' ? \'~\' : false;\n\n	/**\n	 * Representation of a single EventEmitter function.\n	 *\n	 * @param {Function} fn Event handler to be called.\n	 * @param {Mixed} context Context for function execution.\n	 * @param {Boolean} once Only emit once\n	 * @api private\n	 */\n	function EE(fn, context, once) {\n	  this.fn = fn;\n	  this.context = context;\n	  this.once = once || false;\n	}\n\n	/**\n	 * Minimal EventEmitter interface that is molded against the Node.js\n	 * EventEmitter interface.\n	 *\n	 * @constructor\n	 * @api public\n	 */\n	function EventEmitter() {} /* Nothing to set */\n\n	/**\n	 * Holds the assigned EventEmitters by name.\n	 *\n	 * @type {Object}\n	 * @private\n	 */\n	EventEmitter.prototype._events = undefined;\n\n	/**\n	 * Return a list of assigned event listeners.\n	 *\n	 * @param {String} event The events that should be listed.\n	 * @param {Boolean} exists We only need to know if there are listeners.\n	 * @returns {Array|Boolean}\n	 * @api public\n	 */\n	EventEmitter.prototype.listeners = function listeners(event, exists) {\n	  var evt = prefix ? prefix + event : event,\n	      available = this._events && this._events[evt];\n\n	  if (exists) return !!available;\n	  if (!available) return [];\n	  if (available.fn) return [available.fn];\n\n	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n	    ee[i] = available[i].fn;\n	  }\n\n	  return ee;\n	};\n\n	/**\n	 * Emit an event to all registered event listeners.\n	 *\n	 * @param {String} event The name of the event.\n	 * @returns {Boolean} Indication if we\'ve emitted an event.\n	 * @api public\n	 */\n	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n	  var evt = prefix ? prefix + event : event;\n\n	  if (!this._events || !this._events[evt]) return false;\n\n	  var listeners = this._events[evt],\n	      len = arguments.length,\n	      args,\n	      i;\n\n	  if (\'function\' === typeof listeners.fn) {\n	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n	    switch (len) {\n	      case 1:\n	        return (listeners.fn.call(listeners.context), true);\n	      case 2:\n	        return (listeners.fn.call(listeners.context, a1), true);\n	      case 3:\n	        return (listeners.fn.call(listeners.context, a1, a2), true);\n	      case 4:\n	        return (listeners.fn.call(listeners.context, a1, a2, a3), true);\n	      case 5:\n	        return (listeners.fn.call(listeners.context, a1, a2, a3, a4), true);\n	      case 6:\n	        return (listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true);\n	    }\n\n	    for (i = 1, args = new Array(len - 1); i < len; i++) {\n	      args[i - 1] = arguments[i];\n	    }\n\n	    listeners.fn.apply(listeners.context, args);\n	  } else {\n	    var length = listeners.length,\n	        j;\n\n	    for (i = 0; i < length; i++) {\n	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n	      switch (len) {\n	        case 1:\n	          listeners[i].fn.call(listeners[i].context);break;\n	        case 2:\n	          listeners[i].fn.call(listeners[i].context, a1);break;\n	        case 3:\n	          listeners[i].fn.call(listeners[i].context, a1, a2);break;\n	        default:\n	          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n	            args[j - 1] = arguments[j];\n	          }\n\n	          listeners[i].fn.apply(listeners[i].context, args);\n	      }\n	    }\n	  }\n\n	  return true;\n	};\n\n	/**\n	 * Register a new EventListener for the given event.\n	 *\n	 * @param {String} event Name of the event.\n	 * @param {Functon} fn Callback function.\n	 * @param {Mixed} context The context of the function.\n	 * @api public\n	 */\n	EventEmitter.prototype.on = function on(event, fn, context) {\n	  var listener = new EE(fn, context || this),\n	      evt = prefix ? prefix + event : event;\n\n	  if (!this._events) this._events = prefix ? {} : Object.create(null);\n	  if (!this._events[evt]) this._events[evt] = listener;else {\n	    if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];\n	  }\n\n	  return this;\n	};\n\n	/**\n	 * Add an EventListener that\'s only called once.\n	 *\n	 * @param {String} event Name of the event.\n	 * @param {Function} fn Callback function.\n	 * @param {Mixed} context The context of the function.\n	 * @api public\n	 */\n	EventEmitter.prototype.once = function once(event, fn, context) {\n	  var listener = new EE(fn, context || this, true),\n	      evt = prefix ? prefix + event : event;\n\n	  if (!this._events) this._events = prefix ? {} : Object.create(null);\n	  if (!this._events[evt]) this._events[evt] = listener;else {\n	    if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];\n	  }\n\n	  return this;\n	};\n\n	/**\n	 * Remove event listeners.\n	 *\n	 * @param {String} event The event we want to remove.\n	 * @param {Function} fn The listener that we need to find.\n	 * @param {Mixed} context Only remove listeners matching this context.\n	 * @param {Boolean} once Only remove once listeners.\n	 * @api public\n	 */\n	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n	  var evt = prefix ? prefix + event : event;\n\n	  if (!this._events || !this._events[evt]) return this;\n\n	  var listeners = this._events[evt],\n	      events = [];\n\n	  if (fn) {\n	    if (listeners.fn) {\n	      if (listeners.fn !== fn || once && !listeners.once || context && listeners.context !== context) {\n	        events.push(listeners);\n	      }\n	    } else {\n	      for (var i = 0, length = listeners.length; i < length; i++) {\n	        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n	          events.push(listeners[i]);\n	        }\n	      }\n	    }\n	  }\n\n	  //\n	  // Reset the array, or remove it completely if we have no more listeners.\n	  //\n	  if (events.length) {\n	    this._events[evt] = events.length === 1 ? events[0] : events;\n	  } else {\n	    delete this._events[evt];\n	  }\n\n	  return this;\n	};\n\n	/**\n	 * Remove all listeners or only the listeners for the specified event.\n	 *\n	 * @param {String} event The event want to remove all listeners for.\n	 * @api public\n	 */\n	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n	  if (!this._events) return this;\n\n	  if (event) delete this._events[prefix ? prefix + event : event];else this._events = prefix ? {} : Object.create(null);\n\n	  return this;\n	};\n\n	//\n	// Alias methods names because people roll like that.\n	//\n	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n	EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n	//\n	// This function doesn\'t apply anymore.\n	//\n	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n	  return this;\n	};\n\n	//\n	// Expose the prefix.\n	//\n	EventEmitter.prefixed = prefix;\n\n	//\n	// Expose the module.\n	//\n	if (true) {\n	  module.exports = EventEmitter;\n	}\n\n/***/ },\n/* 571 */\n/***/ function(module, exports) {\n\n	\"use strict\";\n\n	module.exports = function (store, definition) {\n	    for (var name in definition) {\n	        if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n	            var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);\n\n	            if (!propertyDescriptor.value || typeof propertyDescriptor.value !== \"function\" || !definition.hasOwnProperty(name)) {\n	                continue;\n	            }\n\n	            store[name] = definition[name].bind(store);\n	        } else {\n	            var property = definition[name];\n\n	            if (typeof property !== \"function\" || !definition.hasOwnProperty(name)) {\n	                continue;\n	            }\n\n	            store[name] = property.bind(store);\n	        }\n	    }\n\n	    return store;\n	};\n\n/***/ },\n/* 572 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	var _ = __webpack_require__(396),\n	    ActionMethods = __webpack_require__(475),\n	    PublisherMethods = __webpack_require__(447),\n	    Keep = __webpack_require__(446);\n\n	var allowed = { preEmit: 1, shouldEmit: 1 };\n\n	/**\n	 * Creates an action functor object. It is mixed in with functions\n	 * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may\n	 * be overridden in the definition object.\n	 *\n	 * @param {Object} definition The action object definition\n	 */\n	var createAction = function createAction(definition) {\n\n	    definition = definition || {};\n	    if (!_.isObject(definition)) {\n	        definition = { actionName: definition };\n	    }\n\n	    for (var a in ActionMethods) {\n	        if (!allowed[a] && PublisherMethods[a]) {\n	            throw new Error(\"Cannot override API method \" + a + \" in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.\");\n	        }\n	    }\n\n	    for (var d in definition) {\n	        if (!allowed[d] && PublisherMethods[d]) {\n	            throw new Error(\"Cannot override API method \" + d + \" in action creation. Use another method name or override it on Reflux.PublisherMethods instead.\");\n	        }\n	    }\n\n	    definition.children = definition.children || [];\n	    if (definition.asyncResult) {\n	        definition.children = definition.children.concat([\"completed\", \"failed\"]);\n	    }\n\n	    var i = 0,\n	        childActions = {};\n	    for (; i < definition.children.length; i++) {\n	        var name = definition.children[i];\n	        childActions[name] = createAction(name);\n	    }\n\n	    var context = _.extend({\n	        eventLabel: \"action\",\n	        emitter: new _.EventEmitter(),\n	        _isAction: true\n	    }, PublisherMethods, ActionMethods, definition);\n\n	    var functor = function functor() {\n	        var triggerType = functor.sync ? \"trigger\" : \"triggerAsync\";\n	        return functor[triggerType].apply(functor, arguments);\n	    };\n\n	    _.extend(functor, childActions, context);\n\n	    Keep.createdActions.push(functor);\n\n	    return functor;\n	};\n\n	module.exports = createAction;\n\n/***/ },\n/* 573 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	Object.defineProperty(exports, \"__esModule\", {\n	    value: true\n	});\n	var Reflux = {\n	    version: {\n	        \"reflux-core\": \"0.3.0\"\n	    }\n	};\n\n	Reflux.ActionMethods = __webpack_require__(475);\n\n	Reflux.ListenerMethods = __webpack_require__(405);\n\n	Reflux.PublisherMethods = __webpack_require__(447);\n\n	Reflux.StoreMethods = __webpack_require__(476);\n\n	Reflux.createAction = __webpack_require__(572);\n\n	Reflux.createStore = __webpack_require__(477);\n\n	var maker = __webpack_require__(478).staticJoinCreator;\n\n	Reflux.joinTrailing = Reflux.all = maker(\"last\"); // Reflux.all alias for backward compatibility\n\n	Reflux.joinLeading = maker(\"first\");\n\n	Reflux.joinStrict = maker(\"strict\");\n\n	Reflux.joinConcat = maker(\"all\");\n\n	var _ = Reflux.utils = __webpack_require__(396);\n\n	Reflux.EventEmitter = _.EventEmitter;\n\n	Reflux.Promise = _.Promise;\n\n	/**\n	 * Convenience function for creating a set of actions\n	 *\n	 * @param definitions the definitions for the actions to be created\n	 * @returns an object with actions of corresponding action names\n	 */\n	Reflux.createActions = (function () {\n	    var reducer = function reducer(definitions, actions) {\n	        Object.keys(definitions).forEach(function (actionName) {\n	            var val = definitions[actionName];\n	            actions[actionName] = Reflux.createAction(val);\n	        });\n	    };\n\n	    return function (definitions) {\n	        var actions = {};\n	        if (definitions instanceof Array) {\n	            definitions.forEach(function (val) {\n	                if (_.isObject(val)) {\n	                    reducer(val, actions);\n	                } else {\n	                    actions[val] = Reflux.createAction(val);\n	                }\n	            });\n	        } else {\n	            reducer(definitions, actions);\n	        }\n	        return actions;\n	    };\n	})();\n\n	/**\n	 * Sets the eventmitter that Reflux uses\n	 */\n	Reflux.setEventEmitter = function (ctx) {\n	    Reflux.EventEmitter = _.EventEmitter = ctx;\n	};\n\n	/**\n	 * Sets the method used for deferring actions and stores\n	 */\n	Reflux.nextTick = function (nextTick) {\n	    _.nextTick = nextTick;\n	};\n\n	Reflux.use = function (pluginCb) {\n	    pluginCb(Reflux);\n	};\n\n	/**\n	 * Provides the set of created actions and stores for introspection\n	 */\n	/*eslint-disable no-underscore-dangle*/\n	Reflux.__keep = __webpack_require__(446);\n	/*eslint-enable no-underscore-dangle*/\n\n	/**\n	 * Warn if Function.prototype.bind not available\n	 */\n	if (!Function.prototype.bind) {\n	    console.error(\"Function.prototype.bind not available. \" + \"ES5 shim required. \" + \"https://github.com/spoike/refluxjs#es5\");\n	}\n\n	exports[\"default\"] = Reflux;\n	module.exports = exports[\"default\"];\n\n/***/ },\n/* 574 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	var _ = __webpack_require__(396);\n\n	module.exports = function mix(def) {\n	    var composed = {\n	        init: [],\n	        preEmit: [],\n	        shouldEmit: []\n	    };\n\n	    var updated = (function mixDef(mixin) {\n	        var mixed = {};\n	        if (mixin.mixins) {\n	            mixin.mixins.forEach(function (subMixin) {\n	                _.extend(mixed, mixDef(subMixin));\n	            });\n	        }\n	        _.extend(mixed, mixin);\n	        Object.keys(composed).forEach(function (composable) {\n	            if (mixin.hasOwnProperty(composable)) {\n	                composed[composable].push(mixin[composable]);\n	            }\n	        });\n	        return mixed;\n	    })(def);\n\n	    if (composed.init.length > 1) {\n	        updated.init = function () {\n	            var args = arguments;\n	            composed.init.forEach(function (init) {\n	                init.apply(this, args);\n	            }, this);\n	        };\n	    }\n	    if (composed.preEmit.length > 1) {\n	        updated.preEmit = function () {\n	            return composed.preEmit.reduce((function (args, preEmit) {\n	                var newValue = preEmit.apply(this, args);\n	                return newValue === undefined ? args : [newValue];\n	            }).bind(this), arguments);\n	        };\n	    }\n	    if (composed.shouldEmit.length > 1) {\n	        updated.shouldEmit = function () {\n	            var args = arguments;\n	            return !composed.shouldEmit.some(function (shouldEmit) {\n	                return !shouldEmit.apply(this, args);\n	            }, this);\n	        };\n	    }\n	    Object.keys(composed).forEach(function (composable) {\n	        if (composed[composable].length === 1) {\n	            updated[composable] = composed[composable][0];\n	        }\n	    });\n\n	    return updated;\n	};\n\n/***/ },\n/* 575 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	var ListenerMethods = __webpack_require__(405),\n	    ListenerMixin = __webpack_require__(448),\n	    _ = __webpack_require__(396);\n\n	module.exports = function (listenable, key) {\n	    return {\n	        getInitialState: function getInitialState() {\n	            if (!_.isFunction(listenable.getInitialState)) {\n	                return {};\n	            } else if (key === undefined) {\n	                return listenable.getInitialState();\n	            } else {\n	                return _.object([key], [listenable.getInitialState()]);\n	            }\n	        },\n	        componentDidMount: function componentDidMount() {\n	            _.extend(this, ListenerMethods);\n	            var me = this,\n	                cb = key === undefined ? this.setState : function (v) {\n	                if (typeof me.isMounted === \"undefined\" || me.isMounted() === true) {\n	                    me.setState(_.object([key], [v]));\n	                }\n	            };\n	            this.listenTo(listenable, cb);\n	        },\n	        componentWillUnmount: ListenerMixin.componentWillUnmount\n	    };\n	};\n\n/***/ },\n/* 576 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	var ListenerMethods = __webpack_require__(405),\n	    ListenerMixin = __webpack_require__(448),\n	    _ = __webpack_require__(396);\n\n	module.exports = function (listenable, key, filterFunc) {\n	    filterFunc = _.isFunction(key) ? key : filterFunc;\n	    return {\n	        getInitialState: function getInitialState() {\n	            if (!_.isFunction(listenable.getInitialState)) {\n	                return {};\n	            } else if (_.isFunction(key)) {\n	                return filterFunc.call(this, listenable.getInitialState());\n	            } else {\n	                // Filter initial payload from store.\n	                var result = filterFunc.call(this, listenable.getInitialState());\n	                if (typeof result !== \"undefined\") {\n	                    return _.object([key], [result]);\n	                } else {\n	                    return {};\n	                }\n	            }\n	        },\n	        componentDidMount: function componentDidMount() {\n	            _.extend(this, ListenerMethods);\n	            var me = this;\n	            var cb = function cb(value) {\n	                if (_.isFunction(key)) {\n	                    me.setState(filterFunc.call(me, value));\n	                } else {\n	                    var result = filterFunc.call(me, value);\n	                    me.setState(_.object([key], [result]));\n	                }\n	            };\n\n	            this.listenTo(listenable, cb);\n	        },\n	        componentWillUnmount: ListenerMixin.componentWillUnmount\n	    };\n	};\n\n/***/ },\n/* 577 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	var ListenerMethods = __webpack_require__(405);\n\n	/**\n	 * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,\n	 * without having to manually set listeners in the `componentDidMount` method.\n	 *\n	 * @param {Action|Store} listenable An Action or Store that should be\n	 *  listened to.\n	 * @param {Function|String} callback The callback to register as event handler\n	 * @param {Function|String} defaultCallback The callback to register as default handler\n	 * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.\n	 */\n	module.exports = function (listenable, callback, initial) {\n	    return {\n	        /**\n	         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\n	         * and then make the call to `listenTo` with the arguments provided to the factory function\n	         */\n	        componentDidMount: function componentDidMount() {\n	            for (var m in ListenerMethods) {\n	                if (this[m] !== ListenerMethods[m]) {\n	                    if (this[m]) {\n	                        throw \"Can\'t have other property \'\" + m + \"\' when using Reflux.listenTo!\";\n	                    }\n	                    this[m] = ListenerMethods[m];\n	                }\n	            }\n	            this.listenTo(listenable, callback, initial);\n	        },\n	        /**\n	         * Cleans up all listener previously registered.\n	         */\n	        componentWillUnmount: ListenerMethods.stopListeningToAll\n	    };\n	};\n\n/***/ },\n/* 578 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\"use strict\";\n\n	var ListenerMethods = __webpack_require__(405);\n\n	/**\n	 * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,\n	 * without having to manually set listeners in the `componentDidMount` method. This version is used\n	 * to automatically set up a `listenToMany` call.\n	 *\n	 * @param {Object} listenables An object of listenables\n	 * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.\n	 */\n	module.exports = function (listenables) {\n	    return {\n	        /**\n	         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`\n	         * and then make the call to `listenTo` with the arguments provided to the factory function\n	         */\n	        componentDidMount: function componentDidMount() {\n	            for (var m in ListenerMethods) {\n	                if (this[m] !== ListenerMethods[m]) {\n	                    if (this[m]) {\n	                        throw \"Can\'t have other property \'\" + m + \"\' when using Reflux.listenToMany!\";\n	                    }\n	                    this[m] = ListenerMethods[m];\n	                }\n	            }\n	            this.listenToMany(listenables);\n	        },\n	        /**\n	         * Cleans up all listener previously registered.\n	         */\n	        componentWillUnmount: ListenerMethods.stopListeningToAll\n	    };\n	};\n\n/***/ },\n/* 579 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	var React = __webpack_require__(133),\n	    classList = \'pure-menu-list\',\n	    classMenuItem = \'pure-menu-item\',\n	    classMenuItemSelected = \'pure-menu-selected\',\n	    classMenuItemLink = \'pure-menu-link\';\n\n	var LanguageMenu = React.createClass({\n	    displayName: \'LanguageMenu\',\n\n	    render: function render() {\n	        // because this.props.__languages is an object, we need to transform it into an array first:\n	        var languages = [];\n	        var keys = Object.keys(this.props.__languages),\n	            that = this;\n	        keys.forEach(function (lang) {\n	            if (that.props.__languages[lang] !== false) {\n	                languages.push(lang);\n	            }\n	        });\n	        return React.createElement(\n	            \'ul\',\n	            { className: classList },\n	            languages.map(function (lang) {\n	                var classname = classMenuItem + (that.props.__lang === lang ? \' \' + classMenuItemSelected : \'\'),\n	                    link = \'/\' + lang + that.props.__uri,\n	                    label = lang.toUpperCase(); // <-- you can specify another label here, perhaps countryflags\n	                return React.createElement(\n	                    \'li\',\n	                    { key: lang, className: classname },\n	                    React.createElement(\n	                        \'a\',\n	                        { href: link, \'data-setlang\': lang, className: classMenuItemLink },\n	                        label\n	                    )\n	                );\n	            })\n	        );\n	    }\n	});\n\n	module.exports = LanguageMenu;\n\n/***/ },\n/* 580 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	__webpack_require__(449);\n	__webpack_require__(482);\n\n	var React = __webpack_require__(133),\n	    Reflux = __webpack_require__(424),\n	    store = __webpack_require__(480),\n	    actions = __webpack_require__(479),\n	    menuitems_first = [\'installation\', \'configuration\'],\n	    menuitems_second = [\'pages\', \'models\', \'async-models\', \'controller\', \'router\', \'appfile\', \'different-devices\', \'markdown\', \'i18n\', \'databases\'],\n	    menuitems_third = [\'developing\', \'production\', \'gulp\'],\n	    PURE_MENU_ = \'pure-menu-\',\n	    PURE_MENU_LINK = PURE_MENU_ + \'link\',\n	    PURE_MENU_ITEM = PURE_MENU_ + \'item\',\n	    PURE_MENU_HEADING = PURE_MENU_ + \'heading\',\n	    PURE_MENU_LIST = PURE_MENU_ + \'list\',\n	    PURE_MENU_SELECTED = \' \' + PURE_MENU_ + \'selected\'; // with leading space\n\n	var Menu = React.createClass({\n	    displayName: \'Menu\',\n\n	    mixins: [Reflux.connect(store)],\n	    render: function render() {\n	        var classname = {},\n	            link = {},\n	            that = this;\n	        var hamburgerClass = \'menu-link\' + (this.state.menuActivated ? \' active\' : \'\');\n	        return React.createElement(\n	            \'div\',\n	            null,\n	            React.createElement(\n	                \'a\',\n	                { className: hamburgerClass, onClick: actions.toggleMenu },\n	                React.createElement(\'span\', null)\n	            ),\n	            React.createElement(\n	                \'div\',\n	                { id: \'leftmenu\' },\n	                React.createElement(\n	                    \'div\',\n	                    { className: \'pure-menu\' },\n	                    React.createElement(\n	                        \'a\',\n	                        { className: PURE_MENU_HEADING },\n	                        this.props.messages.setup\n	                    ),\n	                    React.createElement(\n	                        \'ul\',\n	                        { className: PURE_MENU_LIST },\n	                        menuitems_first.map(function (menuitem) {\n	                            var classname = PURE_MENU_ITEM + (that.props.__path === \'/\' + menuitem ? PURE_MENU_SELECTED : \'\'),\n	                                link = that.props.__langprefix + \'/\' + menuitem,\n	                                label = that.props.messages[menuitem];\n	                            return React.createElement(\n	                                \'li\',\n	                                { key: menuitem, className: classname },\n	                                React.createElement(\n	                                    \'a\',\n	                                    { href: link, className: PURE_MENU_LINK },\n	                                    label\n	                                )\n	                            );\n	                        })\n	                    ),\n	                    React.createElement(\n	                        \'a\',\n	                        { className: PURE_MENU_HEADING },\n	                        this.props.messages.create\n	                    ),\n	                    React.createElement(\n	                        \'ul\',\n	                        { className: PURE_MENU_LIST },\n	                        menuitems_second.map(function (menuitem) {\n	                            var classname = PURE_MENU_ITEM + (that.props.__path === \'/\' + menuitem ? PURE_MENU_SELECTED : \'\'),\n	                                link = that.props.__langprefix + \'/\' + menuitem,\n	                                label = that.props.messages[menuitem];\n	                            return React.createElement(\n	                                \'li\',\n	                                { key: menuitem, className: classname },\n	                                React.createElement(\n	                                    \'a\',\n	                                    { href: link, className: PURE_MENU_LINK },\n	                                    label\n	                                )\n	                            );\n	                        })\n	                    ),\n	                    React.createElement(\n	                        \'a\',\n	                        { className: PURE_MENU_HEADING },\n	                        this.props.messages.build\n	                    ),\n	                    React.createElement(\n	                        \'ul\',\n	                        { className: PURE_MENU_LIST },\n	                        menuitems_third.map(function (menuitem) {\n	                            var classname = PURE_MENU_ITEM + (that.props.__path === \'/\' + menuitem ? PURE_MENU_SELECTED : \'\'),\n	                                link = that.props.__langprefix + \'/\' + menuitem,\n	                                label = that.props.messages[menuitem];\n	                            return React.createElement(\n	                                \'li\',\n	                                { key: menuitem, className: classname },\n	                                React.createElement(\n	                                    \'a\',\n	                                    { href: link, className: PURE_MENU_LINK },\n	                                    label\n	                                )\n	                            );\n	                        })\n	                    )\n	                )\n	            )\n	        );\n	    }\n	});\n\n	module.exports = Menu;\n\n/***/ },\n/* 581 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	__webpack_require__(449);\n	__webpack_require__(481);\n\n	__webpack_require__(484);\n\n	var LangMenuList = __webpack_require__(579);\n\n	var React = __webpack_require__(133),\n	    menuURIs = [\'/\'],\n	    logo = __webpack_require__(583);\n\n	var Menu = React.createClass({\n	    displayName: \'Menu\',\n\n	    render: function render() {\n	        var classname = {},\n	            link = {},\n	            that = this;\n	        menuURIs.forEach(function (menuURI) {\n	            classname[menuURI] = \'pure-menu-item\' + (that.props.__path === menuURI ? \' menu-item-invisible\' : \'\');\n	            link[menuURI] = that.props.__langprefix + menuURI;\n	        });\n	        return React.createElement(\n	            \'div\',\n	            { className: \'top-menu pure-g pure-menu pure-menu-horizontal pure-menu-fixed\' },\n	            React.createElement(\n	                \'div\',\n	                { className: \'pure-u-5-12\' },\n	                React.createElement(\'img\', { src: logo })\n	            ),\n	            React.createElement(\n	                \'div\',\n	                { className: \'pure-u-1-6 center\' },\n	                React.createElement(\n	                    \'div\',\n	                    { className: classname[\'/\'] },\n	                    React.createElement(\n	                        \'a\',\n	                        { href: link[\'/\'], className: \'pure-menu-link\' },\n	                        \'« home\'\n	                    )\n	                )\n	            ),\n	            React.createElement(\n	                \'div\',\n	                { className: \'pure-u-5-12 right\' },\n	                React.createElement(LangMenuList, this.props)\n	            )\n	        );\n	    }\n	});\n\n	module.exports = Menu;\n\n/***/ },\n/* 582 */\n/***/ function(module, exports) {\n\n	\'use strict\';\n\n	var CONSTANTS = {\n	    TOGGLE_MENU: \'toggleMenu\'\n	};\n\n	module.exports = CONSTANTS;\n\n/***/ },\n/* 583 */\n/***/ function(module, exports, __webpack_require__) {\n\n	module.exports = __webpack_require__.p + \"52e737208a0ac30c3de9d327733b50fe.png\"\n\n/***/ },\n/* 584 */\n449,\n/* 585 */\n449,\n/* 586 */\n/***/ function(module, exports, __webpack_require__) {\n\n	\'use strict\';\n\n	__webpack_require__(483);\n	// Because we need to highlight the code, we make use of highlightjs\n	__webpack_require__(585);\n	__webpack_require__(584);\n\n	var React = __webpack_require__(133),\n	    MenuTop = __webpack_require__(581),\n	    MenuLeft = __webpack_require__(580),\n	    Reflux = __webpack_require__(424),\n	    store = __webpack_require__(480);\n\n	var Body = React.createClass({\n	    displayName: \'Body\',\n\n	    mixins: [Reflux.connect(store)],\n	    render: function render() {\n	        var activeClass = this.state.menuActivated ? \'active\' : \'\';\n	        return React.createElement(\n	            \'div\',\n	            { className: activeClass },\n	            React.createElement(MenuTop, this.props),\n	            React.createElement(MenuLeft, this.props),\n	            React.createElement(\n	                \'div\',\n	                { className: \'main\' },\n	                React.createElement(\'h1\', { className: \'header\', dangerouslySetInnerHTML: this.props.pageheader }),\n	                React.createElement(\'div\', { className: \'content\', dangerouslySetInnerHTML: this.props.pagecontent })\n	            )\n	        );\n	    }\n	});\n\n	module.exports = Body;\n\n/***/ }\n]);');window.__itsa_react_server||(window.__itsa_react_server={});window.__itsa_react_server.BodyComponent=arguments[2](11);
	
	
	
	
	
	
	
	
	
	
	
	
	var ItsaRouterClass = __webpack_require__(6);
	new ItsaRouterClass();

/***/ }
]);