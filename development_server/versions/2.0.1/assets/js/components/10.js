webpackJsonp([10],[
/* 0 */,
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var __itsa_view__ = 'controller';if (__itsa_view__) {
	  __itsa_view__ = null;
	}module.exports = __webpack_require__(586);

/***/ },
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */,
/* 55 */,
/* 56 */,
/* 57 */,
/* 58 */,
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */,
/* 232 */,
/* 233 */,
/* 234 */,
/* 235 */,
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */,
/* 242 */,
/* 243 */,
/* 244 */,
/* 245 */,
/* 246 */,
/* 247 */,
/* 248 */,
/* 249 */,
/* 250 */,
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */,
/* 257 */,
/* 258 */,
/* 259 */,
/* 260 */,
/* 261 */,
/* 262 */,
/* 263 */,
/* 264 */,
/* 265 */,
/* 266 */,
/* 267 */,
/* 268 */,
/* 269 */,
/* 270 */,
/* 271 */,
/* 272 */,
/* 273 */,
/* 274 */,
/* 275 */,
/* 276 */,
/* 277 */,
/* 278 */,
/* 279 */,
/* 280 */,
/* 281 */,
/* 282 */,
/* 283 */,
/* 284 */,
/* 285 */,
/* 286 */,
/* 287 */,
/* 288 */,
/* 289 */,
/* 290 */,
/* 291 */,
/* 292 */,
/* 293 */,
/* 294 */,
/* 295 */,
/* 296 */,
/* 297 */,
/* 298 */,
/* 299 */,
/* 300 */,
/* 301 */,
/* 302 */,
/* 303 */,
/* 304 */,
/* 305 */,
/* 306 */,
/* 307 */,
/* 308 */,
/* 309 */,
/* 310 */,
/* 311 */,
/* 312 */,
/* 313 */,
/* 314 */,
/* 315 */,
/* 316 */,
/* 317 */,
/* 318 */,
/* 319 */,
/* 320 */,
/* 321 */,
/* 322 */,
/* 323 */,
/* 324 */,
/* 325 */,
/* 326 */,
/* 327 */,
/* 328 */,
/* 329 */,
/* 330 */,
/* 331 */,
/* 332 */,
/* 333 */,
/* 334 */,
/* 335 */,
/* 336 */,
/* 337 */,
/* 338 */,
/* 339 */,
/* 340 */,
/* 341 */,
/* 342 */,
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */
2,
/* 388 */
3,
/* 389 */
[319, 431, 399, 388, 390],
/* 390 */
[385, 401],
/* 391 */
7,
/* 392 */
[279, 415],
/* 393 */
[296, 453, 399, 389, 518, 408, 434, 435, 419, 436, 388, 387, 415, 402, 390],
/* 394 */
[329, 403, 406, 399, 389, 413, 433, 407, 408, 457, 400, 409, 436, 395, 422, 463, 550, 442, 387, 444, 445, 390],
/* 395 */
[343, 425, 397, 399, 400, 409, 421, 388, 387, 390],
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.capitalize = capitalize;
	exports.callbackName = callbackName;
	exports.isObject = isObject;
	exports.extend = extend;
	exports.isFunction = isFunction;
	exports.object = object;
	exports.isArguments = isArguments;
	exports.throwIf = throwIf;

	function capitalize(string) {
	    return string.charAt(0).toUpperCase() + string.slice(1);
	}

	function callbackName(string, prefix) {
	    prefix = prefix || "on";
	    return prefix + exports.capitalize(string);
	}

	/*
	 * isObject, extend, isFunction, isArguments are taken from undescore/lodash in
	 * order to remove the dependency
	 */

	function isObject(obj) {
	    var type = typeof obj;
	    return type === "function" || type === "object" && !!obj;
	}

	function extend(obj) {
	    if (!isObject(obj)) {
	        return obj;
	    }
	    var source, prop;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	        source = arguments[i];
	        for (prop in source) {
	            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
	                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
	                Object.defineProperty(obj, prop, propertyDescriptor);
	            } else {
	                obj[prop] = source[prop];
	            }
	        }
	    }
	    return obj;
	}

	function isFunction(value) {
	    return typeof value === "function";
	}

	exports.EventEmitter = __webpack_require__(570);

	exports.nextTick = function (callback) {
	    setTimeout(callback, 0);
	};

	function object(keys, vals) {
	    var o = {},
	        i = 0;
	    for (; i < keys.length; i++) {
	        o[keys[i]] = vals[i];
	    }
	    return o;
	}

	function isArguments(value) {
	    return typeof value === "object" && "callee" in value && typeof value.length === "number";
	}

	function throwIf(val, msg) {
	    if (val) {
	        throw Error(msg || val);
	    }
	}

/***/ },
/* 397 */
[290, 387],
/* 398 */
[292, 464],
/* 399 */
30,
/* 400 */
31,
/* 401 */
32,
/* 402 */
33,
/* 403 */
[274, 387],
/* 404 */
[350, 397, 388, 401, 441],
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _ = __webpack_require__(396),
	    maker = __webpack_require__(478).instanceJoinCreator;

	/**
	 * Extract child listenables from a parent from their
	 * children property and return them in a keyed Object
	 *
	 * @param {Object} listenable The parent listenable
	 */
	var mapChildListenables = function mapChildListenables(listenable) {
	    var i = 0,
	        children = {},
	        childName;
	    for (; i < (listenable.children || []).length; ++i) {
	        childName = listenable.children[i];
	        if (listenable[childName]) {
	            children[childName] = listenable[childName];
	        }
	    }
	    return children;
	};

	/**
	 * Make a flat dictionary of all listenables including their
	 * possible children (recursively), concatenating names in camelCase.
	 *
	 * @param {Object} listenables The top-level listenables
	 */
	var flattenListenables = function flattenListenables(listenables) {
	    var flattened = {};
	    for (var key in listenables) {
	        var listenable = listenables[key];
	        var childMap = mapChildListenables(listenable);

	        // recursively flatten children
	        var children = flattenListenables(childMap);

	        // add the primary listenable and chilren
	        flattened[key] = listenable;
	        for (var childKey in children) {
	            var childListenable = children[childKey];
	            flattened[key + _.capitalize(childKey)] = childListenable;
	        }
	    }

	    return flattened;
	};

	/**
	 * A module of methods related to listening.
	 */
	module.exports = {

	    /**
	     * An internal utility function used by `validateListening`
	     *
	     * @param {Action|Store} listenable The listenable we want to search for
	     * @returns {Boolean} The result of a recursive search among `this.subscriptions`
	     */
	    hasListener: function hasListener(listenable) {
	        var i = 0,
	            j,
	            listener,
	            listenables;
	        for (; i < (this.subscriptions || []).length; ++i) {
	            listenables = [].concat(this.subscriptions[i].listenable);
	            for (j = 0; j < listenables.length; j++) {
	                listener = listenables[j];
	                if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    },

	    /**
	     * A convenience method that listens to all listenables in the given object.
	     *
	     * @param {Object} listenables An object of listenables. Keys will be used as callback method names.
	     */
	    listenToMany: function listenToMany(listenables) {
	        var allListenables = flattenListenables(listenables);
	        for (var key in allListenables) {
	            var cbname = _.callbackName(key),
	                localname = this[cbname] ? cbname : this[key] ? key : undefined;
	            if (localname) {
	                this.listenTo(allListenables[key], localname, this[cbname + "Default"] || this[localname + "Default"] || localname);
	            }
	        }
	    },

	    /**
	     * Checks if the current context can listen to the supplied listenable
	     *
	     * @param {Action|Store} listenable An Action or Store that should be
	     *  listened to.
	     * @returns {String|Undefined} An error message, or undefined if there was no problem.
	     */
	    validateListening: function validateListening(listenable) {
	        if (listenable === this) {
	            return "Listener is not able to listen to itself";
	        }
	        if (!_.isFunction(listenable.listen)) {
	            return listenable + " is missing a listen method";
	        }
	        if (listenable.hasListener && listenable.hasListener(this)) {
	            return "Listener cannot listen to this listenable because of circular loop";
	        }
	    },

	    /**
	     * Sets up a subscription to the given listenable for the context object
	     *
	     * @param {Action|Store} listenable An Action or Store that should be
	     *  listened to.
	     * @param {Function|String} callback The callback to register as event handler
	     * @param {Function|String} defaultCallback The callback to register as default handler
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to
	     */
	    listenTo: function listenTo(listenable, callback, defaultCallback) {
	        var desub,
	            unsubscriber,
	            subscriptionobj,
	            subs = this.subscriptions = this.subscriptions || [];
	        _.throwIf(this.validateListening(listenable));
	        this.fetchInitialState(listenable, defaultCallback);
	        desub = listenable.listen(this[callback] || callback, this);
	        unsubscriber = function () {
	            var index = subs.indexOf(subscriptionobj);
	            _.throwIf(index === -1, "Tried to remove listen already gone from subscriptions list!");
	            subs.splice(index, 1);
	            desub();
	        };
	        subscriptionobj = {
	            stop: unsubscriber,
	            listenable: listenable
	        };
	        subs.push(subscriptionobj);
	        return subscriptionobj;
	    },

	    /**
	     * Stops listening to a single listenable
	     *
	     * @param {Action|Store} listenable The action or store we no longer want to listen to
	     * @returns {Boolean} True if a subscription was found and removed, otherwise false.
	     */
	    stopListeningTo: function stopListeningTo(listenable) {
	        var sub,
	            i = 0,
	            subs = this.subscriptions || [];
	        for (; i < subs.length; i++) {
	            sub = subs[i];
	            if (sub.listenable === listenable) {
	                sub.stop();
	                _.throwIf(subs.indexOf(sub) !== -1, "Failed to remove listen from subscriptions list!");
	                return true;
	            }
	        }
	        return false;
	    },

	    /**
	     * Stops all subscriptions and empties subscriptions array
	     */
	    stopListeningToAll: function stopListeningToAll() {
	        var remaining,
	            subs = this.subscriptions || [];
	        while (remaining = subs.length) {
	            subs[0].stop();
	            _.throwIf(subs.length !== remaining - 1, "Failed to remove listen from subscriptions list!");
	        }
	    },

	    /**
	     * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.
	     * @param {Action|Store} listenable The publisher we want to get initial state from
	     * @param {Function|String} defaultCallback The method to receive the data
	     */
	    fetchInitialState: function fetchInitialState(listenable, defaultCallback) {
	        defaultCallback = defaultCallback && this[defaultCallback] || defaultCallback;
	        var me = this;
	        if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {
	            var data = listenable.getInitialState();
	            if (data && _.isFunction(data.then)) {
	                data.then(function () {
	                    defaultCallback.apply(me, arguments);
	                });
	            } else {
	                defaultCallback.call(this, data);
	            }
	        }
	    },

	    /**
	     * The callback will be called once all listenables have triggered at least once.
	     * It will be invoked with the last emission from each listenable.
	     * @param {...Publishers} publishers Publishers that should be tracked.
	     * @param {Function|String} callback The method to call when all publishers have emitted
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
	     */
	    joinTrailing: maker("last"),

	    /**
	     * The callback will be called once all listenables have triggered at least once.
	     * It will be invoked with the first emission from each listenable.
	     * @param {...Publishers} publishers Publishers that should be tracked.
	     * @param {Function|String} callback The method to call when all publishers have emitted
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
	     */
	    joinLeading: maker("first"),

	    /**
	     * The callback will be called once all listenables have triggered at least once.
	     * It will be invoked with all emission from each listenable.
	     * @param {...Publishers} publishers Publishers that should be tracked.
	     * @param {Function|String} callback The method to call when all publishers have emitted
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
	     */
	    joinConcat: maker("all"),

	    /**
	     * The callback will be called once all listenables have triggered.
	     * If a callback triggers twice before that happens, an error is thrown.
	     * @param {...Publishers} publishers Publishers that should be tracked.
	     * @param {Function|String} callback The method to call when all publishers have emitted
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
	     */
	    joinStrict: maker("strict")
	};

/***/ },
/* 406 */
[293, 392, 411, 452, 519, 462, 388, 443],
/* 407 */
[327, 461, 387],
/* 408 */
43,
/* 409 */
[338, 525, 413],
/* 410 */
[275, 403, 560, 390],
/* 411 */
[281, 452, 426, 437, 438, 387],
/* 412 */
[284, 392, 411, 437, 438],
/* 413 */
[320, 389, 417, 435, 419, 399, 418, 467, 387, 390],
/* 414 */
[356, 404, 441],
/* 415 */
[375, 387],
/* 416 */
[268, 465],
/* 417 */
[324, 389, 390],
/* 418 */
[332, 388, 387],
/* 419 */
60,
/* 420 */
[354, 414, 462, 440],
/* 421 */
[358, 387],
/* 422 */
63,
/* 423 */
64,
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Reflux = __webpack_require__(573);

	Reflux.connect = __webpack_require__(575);

	Reflux.connectFilter = __webpack_require__(576);

	Reflux.ListenerMixin = __webpack_require__(448);

	Reflux.listenTo = __webpack_require__(577);

	Reflux.listenToMany = __webpack_require__(578);

	module.exports = Reflux;

/***/ },
/* 425 */
[271, 397, 388, 387],
/* 426 */
[283, 392, 387],
/* 427 */
[287, 459, 387],
/* 428 */
[288, 406, 437, 438, 387],
/* 429 */
[298, 454, 394],
/* 430 */
[299, 387],
/* 431 */
[301, 388, 422, 390],
/* 432 */
[304, 451, 403, 410, 406, 429, 394, 522, 400, 388, 423, 387, 443, 402, 390],
/* 433 */
[321, 389, 408, 387],
/* 434 */
79,
/* 435 */
[334, 415],
/* 436 */
[342, 434, 399, 389, 408, 395, 388, 387, 390],
/* 437 */
[359, 387],
/* 438 */
83,
/* 439 */
84,
/* 440 */
85,
/* 441 */
86,
/* 442 */
[372, 503, 433, 418, 388, 387, 390],
/* 443 */
[373, 391],
/* 444 */
[380, 391],
/* 445 */
[382, 390],
/* 446 */
/***/ function(module, exports) {

	"use strict";

	exports.createdStores = [];

	exports.createdActions = [];

	exports.reset = function () {
	    while (exports.createdStores.length) {
	        exports.createdStores.pop();
	    }
	    while (exports.createdActions.length) {
	        exports.createdActions.pop();
	    }
	};

/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _ = __webpack_require__(396);

	/**
	 * A module of methods for object that you want to be able to listen to.
	 * This module is consumed by `createStore` and `createAction`
	 */
	module.exports = {

	    /**
	     * Hook used by the publisher that is invoked before emitting
	     * and before `shouldEmit`. The arguments are the ones that the action
	     * is invoked with. If this function returns something other than
	     * undefined, that will be passed on as arguments for shouldEmit and
	     * emission.
	     */
	    preEmit: function preEmit() {},

	    /**
	     * Hook used by the publisher after `preEmit` to determine if the
	     * event should be emitted with given arguments. This may be overridden
	     * in your application, default implementation always returns true.
	     *
	     * @returns {Boolean} true if event should be emitted
	     */
	    shouldEmit: function shouldEmit() {
	        return true;
	    },

	    /**
	     * Subscribes the given callback for action triggered
	     *
	     * @param {Function} callback The callback to register as event handler
	     * @param {Mixed} [optional] bindContext The context to bind the callback with
	     * @returns {Function} Callback that unsubscribes the registered event handler
	     */
	    listen: function listen(callback, bindContext) {
	        bindContext = bindContext || this;
	        var eventHandler = function eventHandler(args) {
	            if (aborted) {
	                return;
	            }
	            callback.apply(bindContext, args);
	        },
	            me = this,
	            aborted = false;
	        this.emitter.addListener(this.eventLabel, eventHandler);
	        return function () {
	            aborted = true;
	            me.emitter.removeListener(me.eventLabel, eventHandler);
	        };
	    },

	    /**
	     * Publishes an event using `this.emitter` (if `shouldEmit` agrees)
	     */
	    trigger: function trigger() {
	        var args = arguments,
	            pre = this.preEmit.apply(this, args);
	        args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
	        if (this.shouldEmit.apply(this, args)) {
	            this.emitter.emit(this.eventLabel, args);
	        }
	    },

	    /**
	     * Tries to publish the event on the next tick
	     */
	    triggerAsync: function triggerAsync() {
	        var args = arguments,
	            me = this;
	        _.nextTick(function () {
	            me.trigger.apply(me, args);
	        });
	    },

	    /**
	     * Wraps the trigger mechanism with a deferral function.
	     *
	     * @param {Function} callback the deferral function,
	     *        first argument is the resolving function and the
	     *        rest are the arguments provided from the previous
	     *        trigger invocation
	     */
	    deferWith: function deferWith(callback) {
	        var oldTrigger = this.trigger,
	            ctx = this,
	            resolver = function resolver() {
	            oldTrigger.apply(ctx, arguments);
	        };
	        this.trigger = function () {
	            callback.apply(ctx, [resolver].concat([].splice.call(arguments, 0)));
	        };
	    }

	};

/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _ = __webpack_require__(396),
	    ListenerMethods = __webpack_require__(405);

	/**
	 * A module meant to be consumed as a mixin by a React component. Supplies the methods from
	 * `ListenerMethods` mixin and takes care of teardown of subscriptions.
	 * Note that if you're using the `connect` mixin you don't need this mixin, as connect will
	 * import everything this mixin contains!
	 */
	module.exports = _.extend({

	  /**
	   * Cleans up all listener previously registered.
	   */
	  componentWillUnmount: ListenerMethods.stopListeningToAll

	}, ListenerMethods);

/***/ },
/* 449 */
/***/ function(module, exports) {

	

/***/ },
/* 450 */
109,
/* 451 */
[270, 450, 391, 542, 546, 553, 556, 390],
/* 452 */
[282, 387],
/* 453 */
[297, 436, 387, 390],
/* 454 */
[306, 451, 492, 410, 394, 400, 387, 444],
/* 455 */
[313, 410, 429, 432, 388, 423],
/* 456 */
[326, 512, 463, 465, 466],
/* 457 */
[328, 540],
/* 458 */
[331, 415],
/* 459 */
[335, 389, 417, 419, 401],
/* 460 */
[336, 397, 406, 388],
/* 461 */
120,
/* 462 */
121,
/* 463 */
[361, 554],
/* 464 */
[366, 399, 408, 394, 387, 470, 390],
/* 465 */
124,
/* 466 */
125,
/* 467 */
126,
/* 468 */
[369, 391, 387],
/* 469 */
[370, 391],
/* 470 */
129,
/* 471 */
130,
/* 472 */
[384, 389, 417, 407, 467, 387, 390],
/* 473 */
[264, 474],
/* 474 */
[265, 568, 567],
/* 475 */
/***/ function(module, exports) {

	/**
	 * A module of methods that you want to include in all actions.
	 * This module is consumed by `createAction`.
	 */
	"use strict";

	module.exports = {};

/***/ },
/* 476 */
/***/ function(module, exports) {

	/**
	 * A module of methods that you want to include in all stores.
	 * This module is consumed by `createStore`.
	 */
	"use strict";

	module.exports = {};

/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _ = __webpack_require__(396),
	    Keep = __webpack_require__(446),
	    mixer = __webpack_require__(574),
	    bindMethods = __webpack_require__(571);

	var allowed = { preEmit: 1, shouldEmit: 1 };

	/**
	 * Creates an event emitting Data Store. It is mixed in with functions
	 * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`
	 * and `shouldEmit` may be overridden in the definition object.
	 *
	 * @param {Object} definition The data store object definition
	 * @returns {Store} A data store instance
	 */
	module.exports = function (definition) {

	    var StoreMethods = __webpack_require__(476),
	        PublisherMethods = __webpack_require__(447),
	        ListenerMethods = __webpack_require__(405);

	    definition = definition || {};

	    for (var a in StoreMethods) {
	        if (!allowed[a] && (PublisherMethods[a] || ListenerMethods[a])) {
	            throw new Error("Cannot override API method " + a + " in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.");
	        }
	    }

	    for (var d in definition) {
	        if (!allowed[d] && (PublisherMethods[d] || ListenerMethods[d])) {
	            throw new Error("Cannot override API method " + d + " in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead.");
	        }
	    }

	    definition = mixer(definition);

	    function Store() {
	        var i = 0,
	            arr;
	        this.subscriptions = [];
	        this.emitter = new _.EventEmitter();
	        this.eventLabel = "change";
	        bindMethods(this, definition);
	        if (this.init && _.isFunction(this.init)) {
	            this.init();
	        }
	        if (this.listenables) {
	            arr = [].concat(this.listenables);
	            for (; i < arr.length; i++) {
	                this.listenToMany(arr[i]);
	            }
	        }
	    }

	    _.extend(Store.prototype, ListenerMethods, PublisherMethods, StoreMethods, definition);

	    var store = new Store();
	    Keep.createdStores.push(store);

	    return store;
	};

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Internal module used to create static and instance join methods
	 */

	"use strict";

	var createStore = __webpack_require__(477),
	    _ = __webpack_require__(396);

	var slice = Array.prototype.slice,
	    strategyMethodNames = {
	    strict: "joinStrict",
	    first: "joinLeading",
	    last: "joinTrailing",
	    all: "joinConcat"
	};

	/**
	 * Used in `index.js` to create the static join methods
	 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments
	 * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy
	 */
	exports.staticJoinCreator = function (strategy) {
	    return function () /* listenables... */{
	        var listenables = slice.call(arguments);
	        return createStore({
	            init: function init() {
	                this[strategyMethodNames[strategy]].apply(this, listenables.concat("triggerAsync"));
	            }
	        });
	    };
	};

	/**
	 * Used in `ListenerMethods.js` to create the instance join methods
	 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments
	 * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy
	 */
	exports.instanceJoinCreator = function (strategy) {
	    return function () /* listenables..., callback*/{
	        _.throwIf(arguments.length < 2, "Cannot create a join with less than 2 listenables!");
	        var listenables = slice.call(arguments),
	            callback = listenables.pop(),
	            numberOfListenables = listenables.length,
	            join = {
	            numberOfListenables: numberOfListenables,
	            callback: this[callback] || callback,
	            listener: this,
	            strategy: strategy
	        },
	            i,
	            cancels = [],
	            subobj;
	        for (i = 0; i < numberOfListenables; i++) {
	            _.throwIf(this.validateListening(listenables[i]));
	        }
	        for (i = 0; i < numberOfListenables; i++) {
	            cancels.push(listenables[i].listen(newListener(i, join), this));
	        }
	        reset(join);
	        subobj = { listenable: listenables };
	        subobj.stop = makeStopper(subobj, cancels, this);
	        this.subscriptions = (this.subscriptions || []).concat(subobj);
	        return subobj;
	    };
	};

	// ---- internal join functions ----

	function makeStopper(subobj, cancels, context) {
	    return function () {
	        var i,
	            subs = context.subscriptions,
	            index = subs ? subs.indexOf(subobj) : -1;
	        _.throwIf(index === -1, "Tried to remove join already gone from subscriptions list!");
	        for (i = 0; i < cancels.length; i++) {
	            cancels[i]();
	        }
	        subs.splice(index, 1);
	    };
	}

	function reset(join) {
	    join.listenablesEmitted = new Array(join.numberOfListenables);
	    join.args = new Array(join.numberOfListenables);
	}

	function newListener(i, join) {
	    return function () {
	        var callargs = slice.call(arguments);
	        if (join.listenablesEmitted[i]) {
	            switch (join.strategy) {
	                case "strict":
	                    throw new Error("Strict join failed because listener triggered twice.");
	                case "last":
	                    join.args[i] = callargs;break;
	                case "all":
	                    join.args[i].push(callargs);
	            }
	        } else {
	            join.listenablesEmitted[i] = true;
	            join.args[i] = join.strategy === "all" ? [callargs] : callargs;
	        }
	        emitIfAllListenablesEmitted(join);
	    };
	}

	function emitIfAllListenablesEmitted(join) {
	    for (var i = 0; i < join.numberOfListenables; i++) {
	        if (!join.listenablesEmitted[i]) {
	            return;
	        }
	    }
	    join.callback.apply(join.listener, join.args);
	    reset(join);
	}

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Reflux = __webpack_require__(424),
	    constants = __webpack_require__(582),
	    actions;

	actions = [constants.TOGGLE_MENU];

	module.exports = Reflux.createActions(actions);

/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var menuActivated;

	var Reflux = __webpack_require__(424),
	    actions = __webpack_require__(479),
	    ItsaRefluxClientStorage = __webpack_require__(485);

	var store = Reflux.createStore({
	    mixins: [ItsaRefluxClientStorage],

	    listenables: [actions],

	    onToggleMenu: function onToggleMenu() {
	        menuActivated = !menuActivated;
	        this.trigger({ menuActivated: menuActivated });
	    },

	    getInitialState: function getInitialState() {
	        var initialSate = {
	            menuActivated: false
	        },
	            state = this.readStateFromClientStorage(initialSate);
	        menuActivated = state.menuActivated;
	        return state;
	    }
	});

	module.exports = store;

/***/ },
/* 481 */
449,
/* 482 */
449,
/* 483 */
449,
/* 484 */
449,
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var isNode = typeof global !== 'undefined' && ({}).toString.call(global) === '[object global]' && (!global.document || ({}).toString.call(global.document) !== '[object HTMLDocument]');
	var alreadySet = false;

	var WINDOW = isNode ? {} : window,
	    objectAssign = __webpack_require__(569),
	    localStorage = __webpack_require__(486),
	    KEY_ID = 'itsaRefluxClientStorage',
	    MIN_SESSION_BROWSERS_NO_HISTORY = 3600; // sec

	var setupListener = function setupListener() {
	    // do not use arrow function!
	    if (alreadySet) {
	        return;
	    }
	    // make sure only one listeners kieeps running:
	    alreadySet = true;
	    var eventHandler = function eventHandler(triggerState) {
	        // triggerState is an array where every item is an argument of the triggerFn
	        var newState = {};
	        objectAssign(newState, triggerState[0]);
	        localStorage.setItem(KEY_ID, { time: Date.now(), state: newState });
	    };
	    this.emitter.addListener('change', eventHandler);
	};

	var isBrowserWithHistory = function isBrowserWithHistory() {
	    // only activated to browsers with history-support
	    return WINDOW.history && WINDOW.history.pushState;
	};

	var RefluxClientStorageMixin = {
	    envBrowser: function envBrowser() {
	        return !isNode;
	    },

	    readStateFromClientStorage: function readStateFromClientStorage(initialState) {
	        var localState;
	        if (this.envBrowser() && localStorage) {
	            var controller = __webpack_require__(487);
	            var sessionTime = controller.getProps().__sessiontime;

	            if (!isBrowserWithHistory()) {
	                // force a specific sessiontime, to prevent stateloses during navigation
	                sessionTime = Math.max(sessionTime, MIN_SESSION_BROWSERS_NO_HISTORY);
	            }
	            localState = localStorage.getItem(KEY_ID, true);

	            if (localState && localState.time && localState.time > Date.now() - 1000 * sessionTime) {
	                objectAssign(initialState, localState.state);
	            }
	            setupListener.call(this);
	        }
	        return initialState;
	    }

	};

	module.exports = RefluxClientStorageMixin;
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 486 */
/***/ function(module, exports) {

	'use strict';

	var DATEPATTERN = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z/,
	    // datepattern will return date-type
	REVIVER = function REVIVER(key, value) {
	    return DATEPATTERN.test(value) ? new Date(value) : value;
	};

	var Storage = {
	    /**
	     *
	     *
	     * @method getItem
	     * @param key {String}
	     * @param parseDate {boolean}
	     * @since 0.0.1
	     */
	    getItem: function getItem(key, parseDate) {
	        var value = localStorage.getItem(key),
	            obj;
	        if (value) {
	            try {
	                obj = JSON.parse(value, parseDate ? REVIVER : null);
	            } catch (err) {
	                // error in item: remove it from store
	                obj = {};
	            }
	        }
	        return obj;
	    },

	    /**
	     *
	     *
	     * @method setItem
	     * @param key {String}
	     * @param value {Any}
	     * @since 0.0.1
	     */
	    setItem: function setItem(key, value) {
	        try {
	            value = JSON.stringify(value);
	            localStorage.setItem(key, value);
	        } catch (err) {
	            // error storing
	            return false;
	        }
	        return true;
	    },

	    /**
	     *
	     *
	     * @method removeItem
	     * @param key {String}
	     * @since 0.0.1
	     */
	    removeItem: function removeItem(key) {
	        try {
	            localStorage.removeItem(key);
	        } catch (err) {
	            // error removing
	            return false;
	        }
	        return true;
	    }
	};

	module.exports = Storage;

/***/ },
/* 487 */
[261, 564, 565, 488],
/* 488 */
148,
/* 489 */
[269, 392, 412, 391, 497, 533, 536, 402],
/* 490 */
[272, 392, 411, 412, 391, 395, 404, 443, 471, 402],
/* 491 */
188,
/* 492 */
[273, 493, 458, 561, 387],
/* 493 */
[276, 391, 545, 401, 468, 387],
/* 494 */
[277, 402],
/* 495 */
[278, 392, 412, 420, 394, 402],
/* 496 */
[280, 401],
/* 497 */
[285, 397, 388, 469],
/* 498 */
[286, 403, 391],
/* 499 */
[289, 392, 401],
/* 500 */
[291, 426, 502, 453, 393, 431, 399, 389, 413, 504, 455, 515, 407, 394, 400, 459, 409, 526, 388, 464, 557, 391],
/* 501 */
[294, 409, 547, 442, 445],
/* 502 */
[295, 397, 417, 472, 390],
/* 503 */
[300, 430, 431, 399, 389, 413, 408, 434, 418, 400, 435, 419, 409, 395, 388, 422, 387, 445, 390],
/* 504 */
[302, 389, 413, 555],
/* 505 */
[303, 416, 398, 393, 389, 415],
/* 506 */
[305, 392, 428, 398, 393, 389],
/* 507 */
[307, 392, 428, 398, 393, 389],
/* 508 */
[308, 392, 428, 398, 393, 389],
/* 509 */
[309, 416, 410, 427, 398, 393, 389, 394, 395, 388, 387],
/* 510 */
[310, 398, 393, 389, 390],
/* 511 */
[311, 416, 427, 398, 393, 389, 395, 388],
/* 512 */
[312, 391, 549, 469],
/* 513 */
[314, 416, 410, 427, 398, 393, 389, 395, 388, 387, 390],
/* 514 */
[315, 395, 421, 388, 401],
/* 515 */
[316, 489, 490, 491, 494, 495, 391, 498, 499, 398, 393, 429, 514, 432, 505, 506, 508, 454, 507, 509, 510, 511, 513, 455, 389, 520, 521, 407, 394, 524, 529, 530, 531, 528, 544, 516],
/* 516 */
[317, 403, 517, 394, 400, 559],
/* 517 */
[318, 388],
/* 518 */
215,
/* 519 */
[322, 411],
/* 520 */
[323, 496, 391, 397, 407, 394, 395, 388, 441, 551],
/* 521 */
[325, 403, 411, 430, 393, 433, 406, 418, 432, 400, 461, 395],
/* 522 */
[330, 430, 458, 409, 501],
/* 523 */
[333, 387],
/* 524 */
[337, 425, 397, 406, 456, 460, 421, 388],
/* 525 */
[339, 523],
/* 526 */
[340, 389, 407, 457, 527, 422, 442, 387],
/* 527 */
[341, 397, 425, 460, 421, 388, 401],
/* 528 */
[344, 403],
/* 529 */
[345, 392, 412, 456, 404, 466, 471, 402, 562],
/* 530 */
227,
/* 531 */
[346, 392, 426, 412, 532, 404, 535, 537, 420, 534, 538, 414, 539, 439, 387, 402, 390],
/* 532 */
[347, 404],
/* 533 */
[348, 404],
/* 534 */
[349, 420],
/* 535 */
[351, 414],
/* 536 */
[352, 404],
/* 537 */
[353, 414, 439, 548, 440],
/* 538 */
[355, 414, 440],
/* 539 */
[357, 420],
/* 540 */
237,
/* 541 */
238,
/* 542 */
[360, 541],
/* 543 */
[362, 563],
/* 544 */
[363, 393, 389, 387],
/* 545 */
[364, 391, 543, 468, 387],
/* 546 */
[365, 450],
/* 547 */
[367, 472, 390],
/* 548 */
[368, 439],
/* 549 */
246,
/* 550 */
247,
/* 551 */
248,
/* 552 */
249,
/* 553 */
[371, 552],
/* 554 */
[374, 470],
/* 555 */
252,
/* 556 */
253,
/* 557 */
[376, 389, 387],
/* 558 */
[377, 391],
/* 559 */
[378, 558],
/* 560 */
[379, 423],
/* 561 */
[381, 391, 423, 444],
/* 562 */
259,
/* 563 */
[383, 387],
/* 564 */
[386, 500],
/* 565 */
[262, 566, 473, 473],
/* 566 */
[263, 474],
/* 567 */
153,
/* 568 */
154,
/* 569 */
185,
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;

	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} once Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() {} /* Nothing to set */

	/**
	 * Holds the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;

	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event,
	      available = this._events && this._events[evt];

	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];

	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }

	  return ee;
	};

	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events || !this._events[evt]) return false;

	  var listeners = this._events[evt],
	      len = arguments.length,
	      args,
	      i;

	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

	    switch (len) {
	      case 1:
	        return (listeners.fn.call(listeners.context), true);
	      case 2:
	        return (listeners.fn.call(listeners.context, a1), true);
	      case 3:
	        return (listeners.fn.call(listeners.context, a1, a2), true);
	      case 4:
	        return (listeners.fn.call(listeners.context, a1, a2, a3), true);
	      case 5:
	        return (listeners.fn.call(listeners.context, a1, a2, a3, a4), true);
	      case 6:
	        return (listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true);
	    }

	    for (i = 1, args = new Array(len - 1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length,
	        j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

	      switch (len) {
	        case 1:
	          listeners[i].fn.call(listeners[i].context);break;
	        case 2:
	          listeners[i].fn.call(listeners[i].context, a1);break;
	        case 3:
	          listeners[i].fn.call(listeners[i].context, a1, a2);break;
	        default:
	          if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Functon} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this),
	      evt = prefix ? prefix + event : event;

	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
	  }

	  return this;
	};

	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true),
	      evt = prefix ? prefix + event : event;

	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];
	  }

	  return this;
	};

	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;

	  if (!this._events || !this._events[evt]) return this;

	  var listeners = this._events[evt],
	      events = [];

	  if (fn) {
	    if (listeners.fn) {
	      if (listeners.fn !== fn || once && !listeners.once || context && listeners.context !== context) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }

	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }

	  return this;
	};

	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;

	  if (event) delete this._events[prefix ? prefix + event : event];else this._events = prefix ? {} : Object.create(null);

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};

	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;

	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}

/***/ },
/* 571 */
/***/ function(module, exports) {

	"use strict";

	module.exports = function (store, definition) {
	    for (var name in definition) {
	        if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
	            var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);

	            if (!propertyDescriptor.value || typeof propertyDescriptor.value !== "function" || !definition.hasOwnProperty(name)) {
	                continue;
	            }

	            store[name] = definition[name].bind(store);
	        } else {
	            var property = definition[name];

	            if (typeof property !== "function" || !definition.hasOwnProperty(name)) {
	                continue;
	            }

	            store[name] = property.bind(store);
	        }
	    }

	    return store;
	};

/***/ },
/* 572 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _ = __webpack_require__(396),
	    ActionMethods = __webpack_require__(475),
	    PublisherMethods = __webpack_require__(447),
	    Keep = __webpack_require__(446);

	var allowed = { preEmit: 1, shouldEmit: 1 };

	/**
	 * Creates an action functor object. It is mixed in with functions
	 * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may
	 * be overridden in the definition object.
	 *
	 * @param {Object} definition The action object definition
	 */
	var createAction = function createAction(definition) {

	    definition = definition || {};
	    if (!_.isObject(definition)) {
	        definition = { actionName: definition };
	    }

	    for (var a in ActionMethods) {
	        if (!allowed[a] && PublisherMethods[a]) {
	            throw new Error("Cannot override API method " + a + " in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead.");
	        }
	    }

	    for (var d in definition) {
	        if (!allowed[d] && PublisherMethods[d]) {
	            throw new Error("Cannot override API method " + d + " in action creation. Use another method name or override it on Reflux.PublisherMethods instead.");
	        }
	    }

	    definition.children = definition.children || [];
	    if (definition.asyncResult) {
	        definition.children = definition.children.concat(["completed", "failed"]);
	    }

	    var i = 0,
	        childActions = {};
	    for (; i < definition.children.length; i++) {
	        var name = definition.children[i];
	        childActions[name] = createAction(name);
	    }

	    var context = _.extend({
	        eventLabel: "action",
	        emitter: new _.EventEmitter(),
	        _isAction: true
	    }, PublisherMethods, ActionMethods, definition);

	    var functor = function functor() {
	        var triggerType = functor.sync ? "trigger" : "triggerAsync";
	        return functor[triggerType].apply(functor, arguments);
	    };

	    _.extend(functor, childActions, context);

	    Keep.createdActions.push(functor);

	    return functor;
	};

	module.exports = createAction;

/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var Reflux = {
	    version: {
	        "reflux-core": "0.3.0"
	    }
	};

	Reflux.ActionMethods = __webpack_require__(475);

	Reflux.ListenerMethods = __webpack_require__(405);

	Reflux.PublisherMethods = __webpack_require__(447);

	Reflux.StoreMethods = __webpack_require__(476);

	Reflux.createAction = __webpack_require__(572);

	Reflux.createStore = __webpack_require__(477);

	var maker = __webpack_require__(478).staticJoinCreator;

	Reflux.joinTrailing = Reflux.all = maker("last"); // Reflux.all alias for backward compatibility

	Reflux.joinLeading = maker("first");

	Reflux.joinStrict = maker("strict");

	Reflux.joinConcat = maker("all");

	var _ = Reflux.utils = __webpack_require__(396);

	Reflux.EventEmitter = _.EventEmitter;

	Reflux.Promise = _.Promise;

	/**
	 * Convenience function for creating a set of actions
	 *
	 * @param definitions the definitions for the actions to be created
	 * @returns an object with actions of corresponding action names
	 */
	Reflux.createActions = (function () {
	    var reducer = function reducer(definitions, actions) {
	        Object.keys(definitions).forEach(function (actionName) {
	            var val = definitions[actionName];
	            actions[actionName] = Reflux.createAction(val);
	        });
	    };

	    return function (definitions) {
	        var actions = {};
	        if (definitions instanceof Array) {
	            definitions.forEach(function (val) {
	                if (_.isObject(val)) {
	                    reducer(val, actions);
	                } else {
	                    actions[val] = Reflux.createAction(val);
	                }
	            });
	        } else {
	            reducer(definitions, actions);
	        }
	        return actions;
	    };
	})();

	/**
	 * Sets the eventmitter that Reflux uses
	 */
	Reflux.setEventEmitter = function (ctx) {
	    Reflux.EventEmitter = _.EventEmitter = ctx;
	};

	/**
	 * Sets the method used for deferring actions and stores
	 */
	Reflux.nextTick = function (nextTick) {
	    _.nextTick = nextTick;
	};

	Reflux.use = function (pluginCb) {
	    pluginCb(Reflux);
	};

	/**
	 * Provides the set of created actions and stores for introspection
	 */
	/*eslint-disable no-underscore-dangle*/
	Reflux.__keep = __webpack_require__(446);
	/*eslint-enable no-underscore-dangle*/

	/**
	 * Warn if Function.prototype.bind not available
	 */
	if (!Function.prototype.bind) {
	    console.error("Function.prototype.bind not available. " + "ES5 shim required. " + "https://github.com/spoike/refluxjs#es5");
	}

	exports["default"] = Reflux;
	module.exports = exports["default"];

/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _ = __webpack_require__(396);

	module.exports = function mix(def) {
	    var composed = {
	        init: [],
	        preEmit: [],
	        shouldEmit: []
	    };

	    var updated = (function mixDef(mixin) {
	        var mixed = {};
	        if (mixin.mixins) {
	            mixin.mixins.forEach(function (subMixin) {
	                _.extend(mixed, mixDef(subMixin));
	            });
	        }
	        _.extend(mixed, mixin);
	        Object.keys(composed).forEach(function (composable) {
	            if (mixin.hasOwnProperty(composable)) {
	                composed[composable].push(mixin[composable]);
	            }
	        });
	        return mixed;
	    })(def);

	    if (composed.init.length > 1) {
	        updated.init = function () {
	            var args = arguments;
	            composed.init.forEach(function (init) {
	                init.apply(this, args);
	            }, this);
	        };
	    }
	    if (composed.preEmit.length > 1) {
	        updated.preEmit = function () {
	            return composed.preEmit.reduce((function (args, preEmit) {
	                var newValue = preEmit.apply(this, args);
	                return newValue === undefined ? args : [newValue];
	            }).bind(this), arguments);
	        };
	    }
	    if (composed.shouldEmit.length > 1) {
	        updated.shouldEmit = function () {
	            var args = arguments;
	            return !composed.shouldEmit.some(function (shouldEmit) {
	                return !shouldEmit.apply(this, args);
	            }, this);
	        };
	    }
	    Object.keys(composed).forEach(function (composable) {
	        if (composed[composable].length === 1) {
	            updated[composable] = composed[composable][0];
	        }
	    });

	    return updated;
	};

/***/ },
/* 575 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ListenerMethods = __webpack_require__(405),
	    ListenerMixin = __webpack_require__(448),
	    _ = __webpack_require__(396);

	module.exports = function (listenable, key) {
	    return {
	        getInitialState: function getInitialState() {
	            if (!_.isFunction(listenable.getInitialState)) {
	                return {};
	            } else if (key === undefined) {
	                return listenable.getInitialState();
	            } else {
	                return _.object([key], [listenable.getInitialState()]);
	            }
	        },
	        componentDidMount: function componentDidMount() {
	            _.extend(this, ListenerMethods);
	            var me = this,
	                cb = key === undefined ? this.setState : function (v) {
	                if (typeof me.isMounted === "undefined" || me.isMounted() === true) {
	                    me.setState(_.object([key], [v]));
	                }
	            };
	            this.listenTo(listenable, cb);
	        },
	        componentWillUnmount: ListenerMixin.componentWillUnmount
	    };
	};

/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var ListenerMethods = __webpack_require__(405),
	    ListenerMixin = __webpack_require__(448),
	    _ = __webpack_require__(396);

	module.exports = function (listenable, key, filterFunc) {
	    filterFunc = _.isFunction(key) ? key : filterFunc;
	    return {
	        getInitialState: function getInitialState() {
	            if (!_.isFunction(listenable.getInitialState)) {
	                return {};
	            } else if (_.isFunction(key)) {
	                return filterFunc.call(this, listenable.getInitialState());
	            } else {
	                // Filter initial payload from store.
	                var result = filterFunc.call(this, listenable.getInitialState());
	                if (typeof result !== "undefined") {
	                    return _.object([key], [result]);
	                } else {
	                    return {};
	                }
	            }
	        },
	        componentDidMount: function componentDidMount() {
	            _.extend(this, ListenerMethods);
	            var me = this;
	            var cb = function cb(value) {
	                if (_.isFunction(key)) {
	                    me.setState(filterFunc.call(me, value));
	                } else {
	                    var result = filterFunc.call(me, value);
	                    me.setState(_.object([key], [result]));
	                }
	            };

	            this.listenTo(listenable, cb);
	        },
	        componentWillUnmount: ListenerMixin.componentWillUnmount
	    };
	};

/***/ },
/* 577 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ListenerMethods = __webpack_require__(405);

	/**
	 * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,
	 * without having to manually set listeners in the `componentDidMount` method.
	 *
	 * @param {Action|Store} listenable An Action or Store that should be
	 *  listened to.
	 * @param {Function|String} callback The callback to register as event handler
	 * @param {Function|String} defaultCallback The callback to register as default handler
	 * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.
	 */
	module.exports = function (listenable, callback, initial) {
	    return {
	        /**
	         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
	         * and then make the call to `listenTo` with the arguments provided to the factory function
	         */
	        componentDidMount: function componentDidMount() {
	            for (var m in ListenerMethods) {
	                if (this[m] !== ListenerMethods[m]) {
	                    if (this[m]) {
	                        throw "Can't have other property '" + m + "' when using Reflux.listenTo!";
	                    }
	                    this[m] = ListenerMethods[m];
	                }
	            }
	            this.listenTo(listenable, callback, initial);
	        },
	        /**
	         * Cleans up all listener previously registered.
	         */
	        componentWillUnmount: ListenerMethods.stopListeningToAll
	    };
	};

/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var ListenerMethods = __webpack_require__(405);

	/**
	 * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,
	 * without having to manually set listeners in the `componentDidMount` method. This version is used
	 * to automatically set up a `listenToMany` call.
	 *
	 * @param {Object} listenables An object of listenables
	 * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.
	 */
	module.exports = function (listenables) {
	    return {
	        /**
	         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
	         * and then make the call to `listenTo` with the arguments provided to the factory function
	         */
	        componentDidMount: function componentDidMount() {
	            for (var m in ListenerMethods) {
	                if (this[m] !== ListenerMethods[m]) {
	                    if (this[m]) {
	                        throw "Can't have other property '" + m + "' when using Reflux.listenToMany!";
	                    }
	                    this[m] = ListenerMethods[m];
	                }
	            }
	            this.listenToMany(listenables);
	        },
	        /**
	         * Cleans up all listener previously registered.
	         */
	        componentWillUnmount: ListenerMethods.stopListeningToAll
	    };
	};

/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(133),
	    classList = 'pure-menu-list',
	    classMenuItem = 'pure-menu-item',
	    classMenuItemSelected = 'pure-menu-selected',
	    classMenuItemLink = 'pure-menu-link';

	var LanguageMenu = React.createClass({
	    displayName: 'LanguageMenu',

	    render: function render() {
	        // because this.props.__languages is an object, we need to transform it into an array first:
	        var languages = [];
	        var keys = Object.keys(this.props.__languages),
	            that = this;
	        keys.forEach(function (lang) {
	            if (that.props.__languages[lang] !== false) {
	                languages.push(lang);
	            }
	        });
	        return React.createElement(
	            'ul',
	            { className: classList },
	            languages.map(function (lang) {
	                var classname = classMenuItem + (that.props.__lang === lang ? ' ' + classMenuItemSelected : ''),
	                    link = '/' + lang + that.props.__uri,
	                    label = lang.toUpperCase(); // <-- you can specify another label here, perhaps countryflags
	                return React.createElement(
	                    'li',
	                    { key: lang, className: classname },
	                    React.createElement(
	                        'a',
	                        { href: link, 'data-setlang': lang, className: classMenuItemLink },
	                        label
	                    )
	                );
	            })
	        );
	    }
	});

	module.exports = LanguageMenu;

/***/ },
/* 580 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(449);
	__webpack_require__(482);

	var React = __webpack_require__(133),
	    Reflux = __webpack_require__(424),
	    store = __webpack_require__(480),
	    actions = __webpack_require__(479),
	    menuitems_first = ['installation', 'configuration'],
	    menuitems_second = ['pages', 'models', 'async-models', 'controller', 'router', 'appfile', 'different-devices', 'markdown', 'i18n', 'databases'],
	    menuitems_third = ['developing', 'production', 'gulp'],
	    PURE_MENU_ = 'pure-menu-',
	    PURE_MENU_LINK = PURE_MENU_ + 'link',
	    PURE_MENU_ITEM = PURE_MENU_ + 'item',
	    PURE_MENU_HEADING = PURE_MENU_ + 'heading',
	    PURE_MENU_LIST = PURE_MENU_ + 'list',
	    PURE_MENU_SELECTED = ' ' + PURE_MENU_ + 'selected'; // with leading space

	var Menu = React.createClass({
	    displayName: 'Menu',

	    mixins: [Reflux.connect(store)],
	    render: function render() {
	        var classname = {},
	            link = {},
	            that = this;
	        var hamburgerClass = 'menu-link' + (this.state.menuActivated ? ' active' : '');
	        return React.createElement(
	            'div',
	            null,
	            React.createElement(
	                'a',
	                { className: hamburgerClass, onClick: actions.toggleMenu },
	                React.createElement('span', null)
	            ),
	            React.createElement(
	                'div',
	                { id: 'leftmenu' },
	                React.createElement(
	                    'div',
	                    { className: 'pure-menu' },
	                    React.createElement(
	                        'a',
	                        { className: PURE_MENU_HEADING },
	                        this.props.messages.setup
	                    ),
	                    React.createElement(
	                        'ul',
	                        { className: PURE_MENU_LIST },
	                        menuitems_first.map(function (menuitem) {
	                            var classname = PURE_MENU_ITEM + (that.props.__path === '/' + menuitem ? PURE_MENU_SELECTED : ''),
	                                link = that.props.__langprefix + '/' + menuitem,
	                                label = that.props.messages[menuitem];
	                            return React.createElement(
	                                'li',
	                                { key: menuitem, className: classname },
	                                React.createElement(
	                                    'a',
	                                    { href: link, className: PURE_MENU_LINK },
	                                    label
	                                )
	                            );
	                        })
	                    ),
	                    React.createElement(
	                        'a',
	                        { className: PURE_MENU_HEADING },
	                        this.props.messages.create
	                    ),
	                    React.createElement(
	                        'ul',
	                        { className: PURE_MENU_LIST },
	                        menuitems_second.map(function (menuitem) {
	                            var classname = PURE_MENU_ITEM + (that.props.__path === '/' + menuitem ? PURE_MENU_SELECTED : ''),
	                                link = that.props.__langprefix + '/' + menuitem,
	                                label = that.props.messages[menuitem];
	                            return React.createElement(
	                                'li',
	                                { key: menuitem, className: classname },
	                                React.createElement(
	                                    'a',
	                                    { href: link, className: PURE_MENU_LINK },
	                                    label
	                                )
	                            );
	                        })
	                    ),
	                    React.createElement(
	                        'a',
	                        { className: PURE_MENU_HEADING },
	                        this.props.messages.build
	                    ),
	                    React.createElement(
	                        'ul',
	                        { className: PURE_MENU_LIST },
	                        menuitems_third.map(function (menuitem) {
	                            var classname = PURE_MENU_ITEM + (that.props.__path === '/' + menuitem ? PURE_MENU_SELECTED : ''),
	                                link = that.props.__langprefix + '/' + menuitem,
	                                label = that.props.messages[menuitem];
	                            return React.createElement(
	                                'li',
	                                { key: menuitem, className: classname },
	                                React.createElement(
	                                    'a',
	                                    { href: link, className: PURE_MENU_LINK },
	                                    label
	                                )
	                            );
	                        })
	                    )
	                )
	            )
	        );
	    }
	});

	module.exports = Menu;

/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(449);
	__webpack_require__(481);

	__webpack_require__(484);

	var LangMenuList = __webpack_require__(579);

	var React = __webpack_require__(133),
	    menuURIs = ['/'],
	    logo = __webpack_require__(583);

	var Menu = React.createClass({
	    displayName: 'Menu',

	    render: function render() {
	        var classname = {},
	            link = {},
	            that = this;
	        menuURIs.forEach(function (menuURI) {
	            classname[menuURI] = 'pure-menu-item' + (that.props.__path === menuURI ? ' menu-item-invisible' : '');
	            link[menuURI] = that.props.__langprefix + menuURI;
	        });
	        return React.createElement(
	            'div',
	            { className: 'top-menu pure-g pure-menu pure-menu-horizontal pure-menu-fixed' },
	            React.createElement(
	                'div',
	                { className: 'pure-u-5-12' },
	                React.createElement('img', { src: logo })
	            ),
	            React.createElement(
	                'div',
	                { className: 'pure-u-1-6 center' },
	                React.createElement(
	                    'div',
	                    { className: classname['/'] },
	                    React.createElement(
	                        'a',
	                        { href: link['/'], className: 'pure-menu-link' },
	                        '« home'
	                    )
	                )
	            ),
	            React.createElement(
	                'div',
	                { className: 'pure-u-5-12 right' },
	                React.createElement(LangMenuList, this.props)
	            )
	        );
	    }
	});

	module.exports = Menu;

/***/ },
/* 582 */
/***/ function(module, exports) {

	'use strict';

	var CONSTANTS = {
	    TOGGLE_MENU: 'toggleMenu'
	};

	module.exports = CONSTANTS;

/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "52e737208a0ac30c3de9d327733b50fe.png"

/***/ },
/* 584 */
449,
/* 585 */
449,
/* 586 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(483);
	// Because we need to highlight the code, we make use of highlightjs
	__webpack_require__(585);
	__webpack_require__(584);

	var React = __webpack_require__(133),
	    MenuTop = __webpack_require__(581),
	    MenuLeft = __webpack_require__(580),
	    Reflux = __webpack_require__(424),
	    store = __webpack_require__(480);

	var Body = React.createClass({
	    displayName: 'Body',

	    mixins: [Reflux.connect(store)],
	    render: function render() {
	        var activeClass = this.state.menuActivated ? 'active' : '';
	        return React.createElement(
	            'div',
	            { className: activeClass },
	            React.createElement(MenuTop, this.props),
	            React.createElement(MenuLeft, this.props),
	            React.createElement(
	                'div',
	                { className: 'main' },
	                React.createElement('h1', { className: 'header', dangerouslySetInnerHTML: this.props.pageheader }),
	                React.createElement('div', { className: 'content', dangerouslySetInnerHTML: this.props.pagecontent })
	            )
	        );
	    }
	});

	module.exports = Body;

/***/ }
]);